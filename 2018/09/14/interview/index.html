<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>面试题 | 小橙子学习旅程～ | 人生苦短，学无止境，（-，-）</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="java,锁,cas">
    <meta name="description" content="面试题 参考地址：https://blog.csdn.net/sinat_35512245/article/details/60325685  1.ES 倒排索引 将文章进行分词，去掉停顿次，常用词等，生成关键词 将关键词与文章做关联 将关键词在文章中出现的次数，位置记录，以便高亮排序等  2.spring Mvc 的流程 用户请求url，由DispatcherServlet接受 Dispatch">
<meta name="keywords" content="java,锁,cas">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="https://chengbaobao630@github.io/2018/09/14/interview/index.html">
<meta property="og:site_name" content="小橙子学习旅程～">
<meta property="og:description" content="面试题 参考地址：https://blog.csdn.net/sinat_35512245/article/details/60325685  1.ES 倒排索引 将文章进行分词，去掉停顿次，常用词等，生成关键词 将关键词与文章做关联 将关键词在文章中出现的次数，位置记录，以便高亮排序等  2.spring Mvc 的流程 用户请求url，由DispatcherServlet接受 Dispatch">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-09-14T07:40:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试题">
<meta name="twitter:description" content="面试题 参考地址：https://blog.csdn.net/sinat_35512245/article/details/60325685  1.ES 倒排索引 将文章进行分词，去掉停顿次，常用词等，生成关键词 将关键词与文章做关联 将关键词在文章中出现的次数，位置记录，以便高亮排序等  2.spring Mvc 的流程 用户请求url，由DispatcherServlet接受 Dispatch">
    
        <link rel="alternate" type="application/atom+xml" title="小橙子学习旅程～" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">程呈</h5>
          <a href="mailto:554858452@qq.com" title="554858452@qq.com" class="mail">554858452@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/chengbaobao630" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">面试题</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">面试题</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-09-14T07:40:19.000Z" itemprop="datePublished" class="page-time">
  2018-09-14
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/java/">java</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题"><span class="post-toc-number">1.</span> <span class="post-toc-text">面试题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-ES-倒排索引"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">1.ES 倒排索引</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-spring-Mvc-的流程"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">2.spring Mvc 的流程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-spring-项目的-启动过程"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">3.spring 项目的 启动过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-spring-的循环依赖"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">4.spring 的循环依赖</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-dal-主键生成策略"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">5.dal 主键生成策略</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-jvm垃圾收集"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">6.jvm垃圾收集</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-dubbo-负载均衡"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">7.dubbo 负载均衡</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8-mybatis"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">8.mybatis</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-mongodb"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">9.mongodb</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#10-快速排序"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">10.快速排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#11-spring事物"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">11.spring事物</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#12-cat类似的监控软件"><span class="post-toc-number">1.12.</span> <span class="post-toc-text">12.cat类似的监控软件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-CountDownLatch和CyclicBarrier"><span class="post-toc-number">1.13.</span> <span class="post-toc-text">13.CountDownLatch和CyclicBarrier</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#14-jmm模型"><span class="post-toc-number">1.14.</span> <span class="post-toc-text">14.jmm模型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#15-happens-before-volatile-内存屏障"><span class="post-toc-number">1.15.</span> <span class="post-toc-text">15.happens-before , volatile,内存屏障</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#16-控制线程数-限流等"><span class="post-toc-number">1.16.</span> <span class="post-toc-text">16.控制线程数-限流等</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#17-分布式事物"><span class="post-toc-number">1.17.</span> <span class="post-toc-text">17.分布式事物</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#18-kafka为何高效"><span class="post-toc-number">1.18.</span> <span class="post-toc-text">18.kafka为何高效</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#19-mysql-innodb-，myisam-索引"><span class="post-toc-number">1.19.</span> <span class="post-toc-text">19.mysql-innodb ，myisam,索引</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#20-jvm优化"><span class="post-toc-number">1.20.</span> <span class="post-toc-text">20.jvm优化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#21-redis数据结构及内部结构"><span class="post-toc-number">1.21.</span> <span class="post-toc-text">21.redis数据结构及内部结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#22-zk选举"><span class="post-toc-number">1.22.</span> <span class="post-toc-text">22.zk选举</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#23-nginx"><span class="post-toc-number">1.23.</span> <span class="post-toc-text">23.nginx</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#24-Map的实现类"><span class="post-toc-number">1.24.</span> <span class="post-toc-text">24.Map的实现类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#25-synchronized-和-lock"><span class="post-toc-number">1.25.</span> <span class="post-toc-text">25.synchronized 和  lock</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#26-当执行线程-超过-Executors-jvm如何处理"><span class="post-toc-number">1.26.</span> <span class="post-toc-text">26.当执行线程 超过 Executors jvm如何处理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#27-阻塞队列BlockingQueue"><span class="post-toc-number">1.27.</span> <span class="post-toc-text">27.阻塞队列BlockingQueue</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#28-B-tree数据结构"><span class="post-toc-number">1.28.</span> <span class="post-toc-text">28.B-tree数据结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#29-mysql-索引"><span class="post-toc-number">1.29.</span> <span class="post-toc-text">29.mysql 索引</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#30-dubbo与http区别，优势"><span class="post-toc-number">1.30.</span> <span class="post-toc-text">30.dubbo与http区别，优势</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#31-多路复用-http2-0"><span class="post-toc-number">1.31.</span> <span class="post-toc-text">31.多路复用-http2.0</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#32-快速排序，冒泡排序"><span class="post-toc-number">1.32.</span> <span class="post-toc-text">32.快速排序，冒泡排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#33-spring-及-spring-MVC初始化过程"><span class="post-toc-number">1.33.</span> <span class="post-toc-text">33.spring 及 spring MVC初始化过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#34-GC策略"><span class="post-toc-number">1.34.</span> <span class="post-toc-text">34.GC策略</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#35-IO-NIO-Netty"><span class="post-toc-number">1.35.</span> <span class="post-toc-text">35.IO/NIO Netty</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#36-spring-aop默认的代理方式"><span class="post-toc-number">1.36.</span> <span class="post-toc-text">36.spring aop默认的代理方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#java引用类型"><span class="post-toc-number">1.37.</span> <span class="post-toc-text">java引用类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#jdk各个版本的新特性"><span class="post-toc-number">1.38.</span> <span class="post-toc-text">jdk各个版本的新特性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#InetAddress-getLocalHost-getHostAddress"><span class="post-toc-number">1.39.</span> <span class="post-toc-text">InetAddress.getLocalHost().getHostAddress()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#大数据去重"><span class="post-toc-number">1.40.</span> <span class="post-toc-text">大数据去重</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#bitmap算法"><span class="post-toc-number">1.40.1.</span> <span class="post-toc-text">bitmap算法</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-interview"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">面试题</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-09-14 15:40:19" datetime="2018-09-14T07:40:19.000Z"  itemprop="datePublished">2018-09-14</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/java/">java</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><blockquote>
<p>参考地址：<a href="https://blog.csdn.net/sinat_35512245/article/details/60325685" target="_blank" rel="noopener">https://blog.csdn.net/sinat_35512245/article/details/60325685</a></p>
</blockquote>
<h4 id="1-ES-倒排索引"><a href="#1-ES-倒排索引" class="headerlink" title="1.ES 倒排索引"></a>1.ES 倒排索引</h4><ul>
<li>将文章进行分词，去掉停顿次，常用词等，生成关键词</li>
<li>将关键词与文章做关联</li>
<li>将关键词在文章中出现的次数，位置记录，以便高亮排序等</li>
</ul>
<h4 id="2-spring-Mvc-的流程"><a href="#2-spring-Mvc-的流程" class="headerlink" title="2.spring Mvc 的流程"></a>2.spring Mvc 的流程</h4><ul>
<li>用户请求url，由DispatcherServlet接受</li>
<li>DispatcherServlet调用HandlerMapping寻找处理器</li>
<li>HandlerMapping根据url返回执行链</li>
<li>DispatcherServlet根据Handler找到HandlerAdapter执行（参数封装，数据格式转换，数据验证等）</li>
</ul>
<h4 id="3-spring-项目的-启动过程"><a href="#3-spring-项目的-启动过程" class="headerlink" title="3.spring 项目的 启动过程"></a>3.spring 项目的 启动过程</h4><ul>
<li>ContextLoaderListener 继承 ServletContextListener 项目启动时调用contextInitialized</li>
<li>通过父类contextLoader的initWebApplicationContext方法创建Spring上下文对象。</li>
<li>创建WebApplicationContext,加载bean实例，放入ServletContext中</li>
</ul>
<h4 id="4-spring-的循环依赖"><a href="#4-spring-的循环依赖" class="headerlink" title="4.spring 的循环依赖"></a>4.spring 的循环依赖</h4><p>对象初始化顺序：<br>（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象<br>（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充<br>（3）initializeBean：调用spring xml中的init 方法。</p>
<ul>
<li>设置三级缓存<br>singletonFactories ： 单例对象工厂的cache<br>earlySingletonObjects ：提前暴光的单例对象的Cache<br>singletonObjects：单例对象的cache</li>
<li>A -&gt; B  ,B -&gt;A</li>
<li>A 调用构造方法初始化之后放入三级缓存-&gt;singletonFactories中 （1）</li>
<li>然后执行第二步设置属性：发现依赖与B,然后初始化B</li>
<li>B 调用构造方法，然后设置属性 从三级缓存中找到A,并将A移至二级缓存</li>
<li>B 初始化完毕-&gt;回到A,A继续设置属性 至初始化完毕</li>
<li>B中的A也已经完毕，A中的B也初始化完毕</li>
<li>构造方法循环依赖 无解</li>
</ul>
<h4 id="5-dal-主键生成策略"><a href="#5-dal-主键生成策略" class="headerlink" title="5.dal 主键生成策略"></a>5.dal 主键生成策略</h4><ul>
<li>spring el表达式： {dbId%dbNumBer}</li>
</ul>
<h4 id="6-jvm垃圾收集"><a href="#6-jvm垃圾收集" class="headerlink" title="6.jvm垃圾收集"></a>6.jvm垃圾收集</h4><p>-1.serial 收集器：新生代，停止复制算法，单线程<br>-2.pernew: serial的多线程版本<br>-3.parallel scavenge：新生代，停止复制算法，吞吐量收集器<br>-4.serial old:年老带，标记整理算法<br>-5.CMS：标记清除算法，多线程，最短停止时间。</p>
<h4 id="7-dubbo-负载均衡"><a href="#7-dubbo-负载均衡" class="headerlink" title="7.dubbo 负载均衡"></a>7.dubbo 负载均衡</h4><a href="/2018/09/14/dubbo/" title="Dubbo 学习">Dubbo 学习</a>
<h4 id="8-mybatis"><a href="#8-mybatis" class="headerlink" title="8.mybatis"></a>8.mybatis</h4><h4 id="9-mongodb"><a href="#9-mongodb" class="headerlink" title="9.mongodb"></a>9.mongodb</h4><h4 id="10-快速排序"><a href="#10-快速排序" class="headerlink" title="10.快速排序"></a>10.快速排序</h4><h4 id="11-spring事物"><a href="#11-spring事物" class="headerlink" title="11.spring事物"></a>11.spring事物</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enhancer service A -&gt;&#123;</span><br><span class="line">  enhancer method A,B</span><br><span class="line">  method A-&gt;&#123;</span><br><span class="line">      B</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若代理类型为JDK,Cglib则methdoB的增强无效，以上代理类型是对原类做方法增强，调用methodB的还是未代理的原始类<br>若代理类型为javaassist则不存在问题</p>
<h4 id="12-cat类似的监控软件"><a href="#12-cat类似的监控软件" class="headerlink" title="12.cat类似的监控软件"></a>12.cat类似的监控软件</h4><ul>
<li>ELK；Elasticsearch;Logstash;Kibana</li>
</ul>
<h4 id="13-CountDownLatch和CyclicBarrier"><a href="#13-CountDownLatch和CyclicBarrier" class="headerlink" title="13.CountDownLatch和CyclicBarrier"></a>13.CountDownLatch和CyclicBarrier</h4><p>CountDownLatch</p>
<ul>
<li>递减计数器，不可复用</li>
<li>当前线程等待其他线程达到 某个点 继续执行</li>
</ul>
<p>CyclicBarrier</p>
<ul>
<li>递增计数器，可复用</li>
<li>所有线程至wait状态后一起执行</li>
</ul>
<h4 id="14-jmm模型"><a href="#14-jmm模型" class="headerlink" title="14.jmm模型"></a>14.jmm模型</h4><blockquote>
<p><a href="https://blog.csdn.net/u011080472/article/details/51337422" target="_blank" rel="noopener">https://blog.csdn.net/u011080472/article/details/51337422</a></p>
</blockquote>
<h4 id="15-happens-before-volatile-内存屏障"><a href="#15-happens-before-volatile-内存屏障" class="headerlink" title="15.happens-before , volatile,内存屏障"></a>15.happens-before , volatile,内存屏障</h4><ul>
<li>happens-before指令重排序保证一定的顺序，某些指令一定在另一些指令之前</li>
<li><blockquote>
<p>释放锁一定在下一次获得锁之前。<br>线程中的代码一定在线程start之后<br>A -&gt; B ,B -&gt; C ; 最终 A-&gt;C<br>volatile规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读<br>如果ThreadA执行ThreadB.join()方法则线程B的任意操作happens-before于线程A从ThreadB.join()操作成功返回。<br>一个线程中的每个操作，happens-before于该线程中的任意后续操作<br>一个对象的初始化 一定在finalize() 之前</p>
</blockquote>
</li>
</ul>
<ul>
<li>volatile修饰的变量发生了变化之后会刷到主存并更新到其他使用了的线程的工作内存中，不能保证线程安全</li>
<li>内存屏障：1.阻止屏障两边的指令重排序；2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效</li>
</ul>
<h4 id="16-控制线程数-限流等"><a href="#16-控制线程数-限流等" class="headerlink" title="16.控制线程数-限流等"></a>16.控制线程数-限流等</h4><h4 id="17-分布式事物"><a href="#17-分布式事物" class="headerlink" title="17.分布式事物"></a>17.分布式事物</h4><ul>
<li>两段式提交</li>
<li>最终一致性</li>
<li>补偿机制tcc</li>
</ul>
<h4 id="18-kafka为何高效"><a href="#18-kafka为何高效" class="headerlink" title="18.kafka为何高效"></a>18.kafka为何高效</h4><ul>
<li>消息末尾写，末尾读</li>
<li>zeroCopy //TODO</li>
</ul>
<h4 id="19-mysql-innodb-，myisam-索引"><a href="#19-mysql-innodb-，myisam-索引" class="headerlink" title="19.mysql-innodb ，myisam,索引"></a>19.mysql-innodb ，myisam,索引</h4><h4 id="20-jvm优化"><a href="#20-jvm优化" class="headerlink" title="20.jvm优化"></a>20.jvm优化</h4><ul>
<li>Xmn，Xmx,Xms,Xss</li>
<li>UseG1Gc</li>
</ul>
<h4 id="21-redis数据结构及内部结构"><a href="#21-redis数据结构及内部结构" class="headerlink" title="21.redis数据结构及内部结构"></a>21.redis数据结构及内部结构</h4><ul>
<li>List</li>
<li>Set</li>
<li>Zset：跳跃表</li>
<li>String</li>
<li>Map</li>
</ul>
<h4 id="22-zk选举"><a href="#22-zk选举" class="headerlink" title="22.zk选举"></a>22.zk选举</h4><h4 id="23-nginx"><a href="#23-nginx" class="headerlink" title="23.nginx"></a>23.nginx</h4><h4 id="24-Map的实现类"><a href="#24-Map的实现类" class="headerlink" title="24.Map的实现类"></a>24.Map的实现类</h4><h4 id="25-synchronized-和-lock"><a href="#25-synchronized-和-lock" class="headerlink" title="25.synchronized 和  lock"></a>25.synchronized 和  lock</h4><ul>
<li>性能相差不多</li>
<li>synchronized自动释放，lock需要手动释放避免死锁</li>
<li>lock可以指定锁时间，及后续处理；synchronized只能等待</li>
<li>lock可中断，可公平，sync不行</li>
</ul>
<h4 id="26-当执行线程-超过-Executors-jvm如何处理"><a href="#26-当执行线程-超过-Executors-jvm如何处理" class="headerlink" title="26.当执行线程 超过 Executors jvm如何处理"></a>26.当执行线程 超过 Executors jvm如何处理</h4><ul>
<li>阻塞队列</li>
</ul>
<h4 id="27-阻塞队列BlockingQueue"><a href="#27-阻塞队列BlockingQueue" class="headerlink" title="27.阻塞队列BlockingQueue"></a>27.阻塞队列BlockingQueue</h4><ul>
<li>offer存放，可以存入返回true，否则返回false</li>
<li>offer(E o, long timeout, TimeUnit unit),可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。</li>
<li>put存放，一直阻塞直到可以存放为止</li>
<li>poll获取首位对象，如果规定时间内获取不到返回null</li>
<li>take获取，一直阻塞直到有对象为止</li>
<li>drainTo 一次性获取</li>
</ul>
<h4 id="28-B-tree数据结构"><a href="#28-B-tree数据结构" class="headerlink" title="28.B-tree数据结构"></a>28.B-tree数据结构</h4><ul>
<li>m阶B树</li>
</ul>
<h4 id="29-mysql-索引"><a href="#29-mysql-索引" class="headerlink" title="29.mysql 索引"></a>29.mysql 索引</h4><blockquote>
<p><a href="https://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/mysql-index.html</a></p>
<ul>
<li>!= , like “%%”无法使用索引</li>
<li>or无法索引</li>
<li>最左前缀，最左前缀，可以理解为在复合索引中，越是左边越好<br>因为分别对A,B,C三个列建联合索引index，实际上是建立3个索引，每个索引都包含A<br>A,B,C<br>A,B<br>A</li>
</ul>
</blockquote>
<p>–补充： A，C也是可以使用索引的<br>-</p>
<h4 id="30-dubbo与http区别，优势"><a href="#30-dubbo与http区别，优势" class="headerlink" title="30.dubbo与http区别，优势"></a>30.dubbo与http区别，优势</h4><ul>
<li>##无</li>
</ul>
<h4 id="31-多路复用-http2-0"><a href="#31-多路复用-http2-0" class="headerlink" title="31.多路复用-http2.0"></a>31.多路复用-http2.0</h4><p>B1-&gt;C<br>C-&gt;B1<br>B2-&gt;C<br>C-&gt;B2<br>合并成<br>B1-&gt;C<br>B2-&gt;C<br>C-&gt;B1<br>C-&gt;B2</p>
<h4 id="32-快速排序，冒泡排序"><a href="#32-快速排序，冒泡排序" class="headerlink" title="32.快速排序，冒泡排序"></a>32.快速排序，冒泡排序</h4><h4 id="33-spring-及-spring-MVC初始化过程"><a href="#33-spring-及-spring-MVC初始化过程" class="headerlink" title="33.spring 及 spring MVC初始化过程"></a>33.spring 及 spring MVC初始化过程</h4><p>其实现机制就是springMVC也会自己初始化一个IOC容器，然后将spring web的IOC容器作为父容器，这样就可以使用父容器中注入的bean了，由于是向上继承的，所以父容器无法使用子容器注入的Bean。</p>
<h4 id="34-GC策略"><a href="#34-GC策略" class="headerlink" title="34.GC策略"></a>34.GC策略</h4><blockquote>
<p>参考：<a href="https://www.cnblogs.com/zhguang/p/3257367.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhguang/p/3257367.html</a></p>
</blockquote>
<p>1.serial/serial old</p>
<ul>
<li>serial:新生代：单线程；复制清理 Stop The World</li>
<li>serial old :年老代：单线程；标记整理（sweep清理，compact压缩-空间整理） Stop The World</li>
</ul>
<p>2.ParNew</p>
<ul>
<li>新生代：多线程；复制清理； Stop The World ;关注缩短gc时间</li>
</ul>
<p>3.Parallel Scavenge/Parallel Old</p>
<ul>
<li>Parallel Scavenge:新生代：停止复制；多线程；关注吞吐量</li>
<li>Parallel Old:年老代：多线程；标记整理（Summary（汇总）和Compact（压缩））汇总的意思就是将幸存的对象复制到预先准备好的区域；关注吞吐量</li>
</ul>
<p>4.CMS</p>
<ul>
<li>老年代算法；致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。</li>
<li><ol>
<li>初始标记-&gt;并发标记-&gt;预清理-&gt;可控预清理-&gt;重新标记-&gt;并发清理-&gt;并发重设状态等待下次CMS的触发===具体的说，先2次标记，1次预清理，1次重新标记，再1次清除。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">CMS收集的执行过程是：初始标记(CMS-initial-mark) -&gt; 并发标记(CMS-concurrent-mark) --&gt;预清理(CMS-concurrent-preclean)--&gt;可控预清理(CMS-concurrent-abortable-preclean)-&gt; 重新标记(CMS-remark) -&gt; 并发清除(CMS-concurrent-sweep) -&gt;并发重设状态等待下次CMS的触发(CMS-concurrent-reset)</span><br><span class="line">具体的说，先2次标记，1次预清理，1次重新标记，再1次清除。</span><br><span class="line">1，首先jvm根据-XX:CMSInitiatingOccupancyFraction，-XX:+UseCMSInitiatingOccupancyOnly来决定什么时间开始垃圾收集；</span><br><span class="line">2，如果设置了-XX:+UseCMSInitiatingOccupancyOnly，那么只有当old代占用确实达到了-XX:CMSInitiatingOccupancyFraction参数所设定的比例时才会触发cms gc；</span><br><span class="line">3，如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，那么系统会根据统计数据自行决定什么时候触发cms gc；因此有时会遇到设置了80%比例才cms gc，但是50%时就已经触发了，就是因为这个参数没有设置的原因；</span><br><span class="line">4，当cms gc开始时，首先的阶段是初始标记(CMS-initial-mark)，是stop the world阶段，因此此阶段标记的对象只是从root集最直接可达的对象；</span><br><span class="line">     CMS-initial-mark：961330K（1572864K），指标记时，old代的已用空间和总空间</span><br><span class="line">5，下一个阶段是并发标记(CMS-concurrent-mark)，此阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象，此阶段不需要用户停顿。</span><br><span class="line">       此阶段会打印2条日志：CMS-concurrent-mark-start，CMS-concurrent-mark</span><br><span class="line">6，下一个阶段是CMS-concurrent-preclean，此阶段主要是进行一些预清理，因为标记和应用线程是并发执行的，因此会有些对象的状态在标记后会改变，此阶段正是解决这个问题因为之后的Rescan阶段也会stop the world，为了使暂停的时间尽可能的小，也需要preclean阶段先做一部分工作以节省时间</span><br><span class="line">     此阶段会打印2条日志：CMS-concurrent-preclean-start，CMS-concurrent-preclean</span><br><span class="line">7，下一阶段是CMS-concurrent-abortable-preclean阶段，加入此阶段的目的是使cms gc更加可控一些，作用也是执行一些预清理，以减少Rescan阶段造成应用暂停的时间</span><br><span class="line">     此阶段涉及几个参数：</span><br><span class="line">     -XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束</span><br><span class="line">     -XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行，</span><br><span class="line">      即当eden使用达到此值时，才会开始abortable-preclean阶段</span><br><span class="line">     -XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行</span><br><span class="line">      此阶段会打印一些日志如下：</span><br><span class="line">     CMS-concurrent-abortable-preclean-start，CMS-concurrent-abortable-preclean，</span><br><span class="line">      CMS：abort preclean due to time XXX</span><br><span class="line">8，再下一个阶段是第二个stop the world阶段了，即Rescan阶段，此阶段暂停应用线程，停顿时间比并发标记小得多，但比初始标记稍长。对对象进行重新扫描并标记；</span><br><span class="line">       YG occupancy：964861K（2403008K），指执行时young代的情况</span><br><span class="line">       CMS remark：961330K（1572864K），指执行时old代的情况</span><br><span class="line">      此外，还打印出了弱引用处理、类卸载等过程的耗时</span><br><span class="line">9，再下一个阶段是CMS-concurrent-sweep，进行并发的垃圾清理</span><br><span class="line">10，最后是CMS-concurrent-reset，为下一次cms gc重置相关数据结构</span><br><span class="line"></span><br><span class="line">有2种情况会触发CMS 的悲观full gc，在悲观full gc时，整个应用会暂停</span><br><span class="line">       A，concurrent-mode-failure：预清理阶段可能出现，当cms gc正进行时，此时有新的对象要进行old代，但是old代空间不足造成的。其可能性有：1，O区空间不足以让新生代晋级，2，O区空间用完之前，无法完成对无引用的对象的清理。这表明，当前有大量数据进入内存且无法释放。</span><br><span class="line">       B，promotion-failed：新生代young gc可能出现，当进行young gc时，有部分young代对象仍然可用，但是S1或S2放不下，因此需要放到old代，但此时old代空间无法容纳此。</span><br><span class="line"></span><br><span class="line">影响cms gc时长及触发的参数是以下2个：</span><br><span class="line">        -XX:CMSMaxAbortablePrecleanTime=5000</span><br><span class="line">        -XX:CMSInitiatingOccupancyFraction=80</span><br><span class="line">解决也是针对这两个参数来的，根本的原因是每次请求消耗的内存量过大</span><br><span class="line">解决方式：</span><br><span class="line">      A，针对cms gc的触发阶段，调整-XX:CMSInitiatingOccupancyFraction=50，提早触发cms gc，就可以缓解当old代达到80%，cms gc处理不完，从而造成concurrent mode failure引发full gc</span><br><span class="line">     B，修改-XX:CMSMaxAbortablePrecleanTime=500，缩小CMS-concurrent-abortable-preclean阶段的时间</span><br><span class="line">     C，考虑到cms gc时不会进行compact，因此加入-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">       （cms gc后会进行内存的compact）和-XX:CMSFullGCsBeforeCompaction=4（在full gc4次后会进行compact）参数</span><br><span class="line"></span><br><span class="line">在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。</span><br><span class="line">CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。</span><br><span class="line">另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。所以使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。</span><br><span class="line">还有，CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>5.G1<br>//TODO<br>rcemcsdhneogbbdc</p>
<h4 id="35-IO-NIO-Netty"><a href="#35-IO-NIO-Netty" class="headerlink" title="35.IO/NIO Netty"></a>35.IO/NIO Netty</h4><h4 id="36-spring-aop默认的代理方式"><a href="#36-spring-aop默认的代理方式" class="headerlink" title="36.spring aop默认的代理方式"></a>36.spring aop默认的代理方式</h4><p>jdk代理，可以通过proxy-target-class修改<br>proxy-target-class属性值决定是基于接口的还是基于类的代理被创建。</p>
<p>如果proxy-target-class 属性值被设置为true，那么基于类的代理将起作用（这时需要cglib库）。</p>
<p>如果proxy-target-class属值被设置为false或者这个属性被省略，那么标准的JDK 基于接口的代理。</p>
<p>如果不给出 proxy-target-class，就按 proxy-target-class=“false”对待，也即是按JDK proxy来处理的。</p>
<h4 id="java引用类型"><a href="#java引用类型" class="headerlink" title="java引用类型"></a>java引用类型</h4><p>强引用 StrongReference</p>
<p>如果一个对象具有强引用，那么垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误，使得程序异常停止。</p>
<p>Object object = new Object(); 即是一个强引用。</p>
<p>软引用 SoftReference</p>
<p>如果一个对象只具有软引用，那么垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收这些对象。软引用对象被回收后，Java 虚拟机会把这个软引用加入到与之关联的引用队列中。</p>
<p>弱引用 WeakReference</p>
<p>如果一个对象只具有弱引用，那么垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。与软引用相同，弱引用对象被回收后，Java 虚拟机会把这个弱引用加入到与之关联的引用队列中。</p>
<p>虚引用 PhantomReference</p>
<p>虚引用并不决定对象生命周期，如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。与软引用和弱引用不同的是，虚引用必须关联一个引用队列。</p>
<p>当垃圾回收器准备回收一个对象之前，如果发现它还具有虚引用，就会在对象回收前把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否加入了虚引用，来了解被引用的对象是否将要被回收，那么就可以在其被回收之前采取必要的行动。</p>
<h4 id="jdk各个版本的新特性"><a href="#jdk各个版本的新特性" class="headerlink" title="jdk各个版本的新特性"></a>jdk各个版本的新特性</h4><p>jdk1.5的新特性：</p>
<ol>
<li>泛型<br>ArrayList list=new ArrayList()——&gt;ArrayList<integer>list=new ArrayList<integer>();<br>2 自动装箱/拆箱<br>nt i=list.get(0).parseInt();——–&gt;int i=list.get(0);原始类型与对应的包装类不用显式转换<br>3 for-each<br>i=0;i&lt;a.length;i++————&gt;for(int i:a){……}<br>4 static import<br>Math.sqrt();—————&gt;sqrt();<br>5 变长参数<br>int sum(int …intlist)有任意个参数,把他看作数组</integer></integer></li>
</ol>
<p>jdk1.6的新特性<br>1.增强的for循环语句<br>Integer[] numbers = computeNumbers();<br>for (int i=0; i &lt; numbers.length ; i++)<br>sum += numbers[i];<br>||<br>int sum = 0;<br>for ( int number: computeNumbers() )<br>sum += number;<br>2.监视和管理<br>Java SE 6中对内存泄漏增强了分析以及诊断能力。当遇到java.lang.OutOfMemory异常的时候，可以得到一个完整的堆栈信息，<br>并且当堆已经满了的时候，会产生一个Log文件来记录这个致命错误。另外，JVM还添加了一个选项，允许你在堆满的时候运行脚本。<br>3.插入式注解处理<br>插入式注解处理API(JSR 269)提供一套标准API来处理Annotations<br>4.安全性</p>
<p>jdk1.7的新特性<br>1.模块化特性<br>Java7也是采用了模块的划分方式来提速，一些不是必须的模块并没有下载和安装，当虚拟机需要的时候，再下载相应的模块，<br>同时对启动速度也有了很大的改善。<br>2.多语言支持<br>Java7的虚拟机对多种动态程序语言增加了支持，比如：Rubby、 Python等等。<br>3.开发者的开发效率得到了改善<br>switch中可以使用字符串<br>在多线程并发与控制方面：轻量级的分离与合并框架，一个支持并发访问的HashMap等等。<br>通过注解增强程序的静态检查。<br>提供了一些新的API用于文件系统的访问、异步的输入输出操作、Socket通道的配置与绑定、多点数据包的传送等等。<br>4.执行效率的提高<br>对对象指针由64位压缩到与32位指针相匹配的技术使得内存和内存带块的消耗得到了很大的降低因而提高了执行效率。<br>提供了新的垃圾回收机制（G1）来降低垃圾回收的负载和增强垃圾回收的效果。<br>5.try-with-resources<br>  try开启资源代码块外面自动释放<br>6.泛型实例化类型自动推断<br>  List<string> list = new ArrayList&lt;&gt;();</string></p>
<ol start="7">
<li>catch多个异常 以|分割</li>
</ol>
<p>JDK1.8的新特性<br>一、接口的默认方法<br>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法。<br>二、Lambda 表达式<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：<br>Collections.sort(names, (String a, String b) -&gt; {</p>
<pre><code>return b.compareTo(a);
</code></pre><p>});<br>三、函数式接口<br>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。<br>四、方法与构造函数引用<br>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：<br>converter = something::startsWith;</p>
<p>String converted = converter.convert(“Java”);</p>
<p>System.out.println(converted);<br>五、Lambda 作用域<br>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。<br>六、访问局部变量<br>可以直接在lambda表达式中访问外层的局部变量：<br>七、访问对象字段与静态变量<br>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：<br>八、访问接口的默认方法<br>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。<br> JDK1.9 新特性<br>java 7 2011发布，Java 8 2014发布，java9发布于2017年9月21日。 你可能已经听说过 Java 9 的模块系统，但是这个新版本还有许多其它的更新。 这里有九个令人兴奋的新功能将与 Java 9 一起发布。</p>
<ol>
<li>Java 平台级模块系统</li>
</ol>
<p>Java 9 的定义功能是一套全新的模块系统。当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长。这时候就得面对两个基础的问题: 很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共类所访问到, 这样就会导致无意中使用了并不想被公开访问的 API。此外，类路径本身也存在问题: 你怎么知晓所有需要的 JAR 都已经有了, 或者是不是会有重复的项呢? 模块系统把这俩个问题都给解决了。</p>
<p>模块化的 JAR 文件都包含一个额外的模块描述器。在这个模块描述器中, 对其它模块的依赖是通过 “requires” 来表示的。另外, “exports” 语句控制着哪些包是可以被其它模块访问到的。所有不被导出的包默认都封装在模块的里面。如下是一个模块描述器的示例，存在于 “module-info.java” 文件中:</p>
<p>1<br>2<br>3<br>4<br>5<br>module<br>blog {</p>
<p>exports<br>com.pluralsight.blog;</p>
<p>requires<br>cms;<br>}<br>我们可以如下展示模块：</p>
<p>请注意，两个模块都包含封装的包，因为它们没有被导出（使用橙色盾牌可视化）。 没有人会偶然地使用来自这些包中的类。Java 平台本身也使用自己的模块系统进行了模块化。通过封装 JDK 的内部类，平台更安全，持续改进也更容易。</p>
<p>当启动一个模块化应用时， JVM 会验证是否所有的模块都能使用，这基于 <code>requires</code> 语句——比脆弱的类路径迈进了一大步。模块允许你更好地强制结构化封装你的应用并明确依赖。你可以在这个课程中学习更多关于 Java 9 中模块工作的信息 。</p>
<ol start="2">
<li>Linking</li>
</ol>
<p>当你使用具有显式依赖关系的模块和模块化的 JDK 时，新的可能性出现了。你的应用程序模块现在将声明其对其他应用程序模块的依赖以及对其所使用的 JDK 模块的依赖。为什么不使用这些信息创建一个最小的运行时环境，其中只包含运行应用程序所需的那些模块呢？ 这可以通过 Java 9 中的新的 jlink 工具实现。你可以创建针对应用程序进行优化的最小运行时映像而不需要使用完全加载 JDK 安装版本。</p>
<ol start="3">
<li>JShell : 交互式 Java REPL</li>
</ol>
<p>许多语言已经具有交互式编程环境，Java 现在加入了这个俱乐部。您可以从控制台启动 jshell ，并直接启动输入和执行 Java 代码。 jshell 的即时反馈使它成为探索 API 和尝试语言特性的好工具。</p>
<p>测试一个 Java 正则表达式是一个很好的说明 jshell 如何使您的生活更轻松的例子。 交互式 shell 还可以提供良好的教学环境以及提高生产力，您可以在此了解更多信息。在教人们如何编写 Java 的过程中，不再需要解释 “public static void main（String [] args）” 这句废话。</p>
<ol start="4">
<li>改进的 Javadoc</li>
</ol>
<p>有时一些小事情可以带来很大的不同。你是否就像我一样在一直使用 Google 来查找正确的 Javadoc 页面呢？ 这不再需要了。Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。此外，你会注意到，每个 Javadoc 页面都包含有关 JDK 模块类或接口来源的信息。</p>
<ol start="5">
<li>集合工厂方法</li>
</ol>
<p>通常，您希望在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 “add” 调用，使得代码重复。 Java 9，添加了几种集合工厂方法：</p>
<p>1<br>2<br>Set<integer><br>ints = Set.of(<br>1<br>,<br>2<br>,<br>3<br>);<br>List<string><br>strings = List.of(<br>“first”<br>,<br>“second”<br>);<br>除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。 事实上，从工厂方法返回已放入数个元素的集合实现是高度优化的。这是可能的，因为它们是不可变的：在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。</string></integer></p>
<ol start="6">
<li>改进的 Stream API</li>
</ol>
<p>长期以来，Stream API 都是 Java 标准库最好的改进之一。通过这套 API 可以在集合上建立用于转换的申明管道。在 Java 9 中它会变得更好。Stream 接口中添加了 4 个新的方法：dropWhile, takeWhile, ofNullable。还有个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代：</p>
<p>1<br>IntStream.iterate(<br>1<br>,<br>i -&gt; i &lt;<br>100<br>,<br>i -&gt; i +<br>1<br>).forEach(System.out::println);<br>第二个参数是一个 Lambda，它会在当前 IntStream 中的元素到达 100 的时候返回 true。因此这个简单的示例是向控制台打印 1 到 99。</p>
<p>除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。现在可以通过 Optional 的新方法 <code>stram</code> 将一个 Optional 对象转换为一个(可能是空的) Stream 对象：</p>
<p>1<br>Stream<integer><br>s = Optional.of(<br>1<br>).stream();<br>在组合复杂的 Stream 管道时，将 Optional 转换为 Stream 非常有用。</integer></p>
<ol start="7">
<li>私有接口方法</li>
</ol>
<p>Java 8 为我们带来了接口的默认方法。 接口现在也可以包含行为，而不仅仅是方法签名。 但是，如果在接口上有几个默认方法，代码几乎相同，会发生什么情况？ 通常，您将重构这些方法，调用一个可复用的私有方法。 但默认方法不能是私有的。 将复用代码创建为一个默认方法不是一个解决方案，因为该辅助方法会成为公共API的一部分。 使用 Java 9，您可以向接口添加私有辅助方法来解决此问题：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>public<br>interface</p>
<p>MyInterface<br>{</p>
<p>void<br>normalInterfaceMethod();</p>
<p>default<br>void</p>
<p>interfaceMethodWithDefault()<br>{  init(); }</p>
<p>default<br>void</p>
<p>anotherDefaultMethod()<br>{ init(); }</p>
<p>//<br>This method is not part of the public API exposed by MyInterface</p>
<p>private<br>void</p>
<p>init()<br>{ System.out.println(<br>“Initializing”<br>);<br>}<br>}<br>如果您使用默认方法开发 API ，那么私有接口方法可能有助于构建其实现。</p>
<ol start="8">
<li>HTTP/2</li>
</ol>
<p>Java 9 中有新的方式来处理 HTTP 调用。这个迟到的特性用于代替老旧的 <code>HttpURLConnection</code> API，并提供对 WebSocket 和 HTTP/2 的支持。注意：新的 HttpClient API 在 Java 9 中以所谓的孵化器模块交付。也就是说，这套 API 不能保证 100% 完成。不过你可以在 Java 9 中开始使用这套 API：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>HttpClient<br>client = HttpClient.newHttpClient();</p>
<p>HttpRequest<br>req =</p>
<p>HttpRequest.newBuilder(URI.create(<br>“<a href="http://www.google.com&quot;" target="_blank" rel="noopener">http://www.google.com&quot;</a><br>))</p>
<p>.header(<br>“User-Agent”<br>,<br>“Java”<br>)</p>
<p>.GET()</p>
<p>.build();</p>
<p>HttpResponse<string><br>resp = client.send(req, HttpResponse.BodyHandler.asString());<br>HttpResponse<string> resp = client.send(req, HttpResponse.BodyHandler.asString());<br>除了这个简单的请求/响应模型之外，HttpClient 还提供了新的 API 来处理 HTTP/2 的特性，比如流和服务端推送。</string></string></p>
<ol start="9">
<li>多版本兼容 JAR</li>
</ol>
<p>我们最后要来着重介绍的这个特性对于库的维护者而言是个特别好的消息。当一个新版本的 Java 出现的时候，你的库用户要花费数年时间才会切换到这个新的版本。这就意味着库得去向后兼容你想要支持的最老的 Java 版本 (许多情况下就是 Java 6 或者 7)。这实际上意味着未来的很长一段时间，你都不能在库中运用 Java 9 所提供的新特性。幸运的是，多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>multirelease.jar<br>├──<br>META-INF<br>│<br>└── versions<br>│<br>└──<br>9<br>│<br>└── multirelease<br>│<br>└── Helper.<br>class<br>├──<br>multirelease</p>
<p>├──<br>Helper.<br>class</p>
<p>└──<br>Main.<br>class<br>在上述场景中， multirelease.jar 可以在 Java 9 中使用, 不过 Helper 这个类使用的不是顶层的 multirelease.Helper 这个 class, 而是处在“META-INF/versions/9”下面的这个。这是特别为 Java 9 准备的 class 版本，可以运用 Java 9 所提供的特性和库。同时，在早期的 Java 诸版本中使用这个 JAR 也是能运行的，因为较老版本的 Java 只会看到顶层的这个 Helper 类。</p>
<h4 id="InetAddress-getLocalHost-getHostAddress"><a href="#InetAddress-getLocalHost-getHostAddress" class="headerlink" title="InetAddress.getLocalHost().getHostAddress()"></a>InetAddress.getLocalHost().getHostAddress()</h4><p>获取本机localhost配置的域名和地址<br>docker - dubbo 在宿主机中加上 docker镜像的hostname -&gt; 本机ip<br>镜像启动时 -h hostname<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">本机中：</span><br><span class="line">echo 192.168.103.144 docker1.com &gt; /etc/hosts</span><br><span class="line"></span><br><span class="line">docker镜像启动时</span><br><span class="line">docker run -h docker1.com</span><br></pre></td></tr></table></figure></p>
<h4 id="大数据去重"><a href="#大数据去重" class="headerlink" title="大数据去重"></a>大数据去重</h4><h5 id="bitmap算法"><a href="#bitmap算法" class="headerlink" title="bitmap算法"></a>bitmap算法</h5><blockquote>
<p><a href="https://blog.csdn.net/pipisorry/article/details/62443757?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">https://blog.csdn.net/pipisorry/article/details/62443757?utm_source=itdadao&amp;utm_medium=referral</a></p>
</blockquote>
<p>核心思想，将数值转换成位存储和运算。<br>java中bitset<br>//todo</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-09-14T07:40:19.000Z" itemprop="dateUpdated">2018-09-14 15:40:19</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2018/09/14/interview/" target="_blank" rel="external">https://chengbaobao630@github.io/2018/09/14/interview/</a>
        
    </div>
    
    <footer>
        <a href="https://chengbaobao630@github.io">
            <img src="/img/avatar.jpg" alt="程呈">
            程呈
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cas/">cas</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/锁/">锁</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://chengbaobao630@github.io/2018/09/14/interview/&title=《面试题》 — 小橙子学习旅程～&pic=https://chengbaobao630@github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://chengbaobao630@github.io/2018/09/14/interview/&title=《面试题》 — 小橙子学习旅程～&source=记录的比较杂，之后会慢慢的整理起来" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://chengbaobao630@github.io/2018/09/14/interview/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面试题》 — 小橙子学习旅程～&url=https://chengbaobao630@github.io/2018/09/14/interview/&via=https://chengbaobao630@github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://chengbaobao630@github.io/2018/09/14/interview/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/09/14/kotlin(0)/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">KOTLIN - 基础-1</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/09/14/hashMap/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">HashMap</h4>
      </a>
    </div>
  
</nav>



    

















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>程呈 &copy; 2018 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://chengbaobao630@github.io/2018/09/14/interview/&title=《面试题》 — 小橙子学习旅程～&pic=https://chengbaobao630@github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://chengbaobao630@github.io/2018/09/14/interview/&title=《面试题》 — 小橙子学习旅程～&source=记录的比较杂，之后会慢慢的整理起来" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://chengbaobao630@github.io/2018/09/14/interview/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面试题》 — 小橙子学习旅程～&url=https://chengbaobao630@github.io/2018/09/14/interview/&via=https://chengbaobao630@github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://chengbaobao630@github.io/2018/09/14/interview/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLUlEQVR42u3ay47CMBBE0fz/T4ftSGCnqtowcvt6hSBKfILUcj+uS173nzX69f3K9zW6RnnKggUDBoxtGfUHz+8836L73CEVBgwYBzCUTSib01+KEtaVvcGAAQPG/LNyn+zVwIABA0adkYVj9/gIAwYMGNlhbpSIZkH2H3JxGDBgbMjQq+6///yV/gYMGDC2YtzmmgdcpSU5D9Z3tGDAgNGb4ZbJsqJY1h6whz9gwIDRlKEkh6uuyQK0BIMBA0ZrRlbKN2J5FHzda2DAgHECw00pK4BVTwyDLwwYMDZk6LfQj4NKuc0Nzca0CAwYMJoy3NK80tq0U9DCoRMGDBi9GW6Ry00+3cDt1tA+5OIwYMBox1iVWOqBWGkt2PeBAQNGa4ayCX2jq6j6AMdV2TQMGDA2YWQBt55wZuF4+A0MGDBaM/SivL4tPQXVmwHhsAUMGDBaMOrFMn0KYm1stHNuGDBgNGK4RflKQb8yggYDBoxzGMpFWRLrHgcrrVMYMGCcwKgPmGZHQHd81qgdwoABoykjG1F1N1dPdx8CLgwYMFoz6g3LbLzVLa49zOHCgAGjHeM2V5buKqFWeZUP/wMMGDCaMtxmpNvmzAKrvnUbAwMGjG0Z2eb00ptbngtTXxgwYBzAyKatsmNf5ag3fC4MGDBgyCMUWen/K3MiMGDAOJihJ5/6UEWltAcDBoxzGPWxLYVUKag9BH0YMGC0ZmQHuwxWaXMuaGTCgAFjP8YLxyuTYZwuiQMAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
