{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Cheng Cheng","url":"https://chengbaobao630@github.io"},"pages":[{"title":"","date":"2018-09-07T02:08:45.300Z","updated":"2018-09-06T16:03:34.000Z","comments":false,"path":"categories/index.html","permalink":"https://chengbaobao630@github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-09-07T02:08:45.724Z","updated":"2018-09-06T16:03:34.000Z","comments":false,"path":"tags/index.html","permalink":"https://chengbaobao630@github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"rust_module","slug":"rust-module","date":"2018-09-12T04:17:04.403Z","updated":"2018-09-12T04:17:04.379Z","comments":true,"path":"2018/09/12/rust-module/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/12/rust-module/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"面试题","slug":"interview","date":"2018-09-11T03:04:21.978Z","updated":"2018-09-11T03:04:21.938Z","comments":true,"path":"2018/09/11/interview/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/11/interview/","excerpt":"","text":"面试题 参考地址：https://blog.csdn.net/sinat_35512245/article/details/60325685 1.ES 倒排索引 将文章进行分词，去掉停顿次，常用词等，生成关键词 将关键词与文章做关联 将关键词在文章中出现的次数，位置记录，以便高亮排序等 2.spring Mvc 的流程 用户请求url，由DispatcherServlet接受 DispatcherServlet调用HandlerMapping寻找处理器 HandlerMapping根据url返回执行链 DispatcherServlet根据Handler找到HandlerAdapter执行（参数封装，数据格式转换，数据验证等） 3.spring 项目的 启动过程 ContextLoaderListener 继承 ServletContextListener 项目启动时调用contextInitialized 通过父类contextLoader的initWebApplicationContext方法创建Spring上下文对象。 创建WebApplicationContext,加载bean实例，放入ServletContext中 4.spring 的循环依赖对象初始化顺序：（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充（3）initializeBean：调用spring xml中的init 方法。 设置三级缓存singletonFactories ： 单例对象工厂的cacheearlySingletonObjects ：提前暴光的单例对象的CachesingletonObjects：单例对象的cache A -&gt; B ,B -&gt;A A 调用构造方法初始化之后放入三级缓存-&gt;singletonFactories中 （1） 然后执行第二步设置属性：发现依赖与B,然后初始化B B 调用构造方法，然后设置属性 从三级缓存中找到A,并将A移至二级缓存 B 初始化完毕-&gt;回到A,A继续设置属性 至初始化完毕 B中的A也已经完毕，A中的B也初始化完毕 构造方法循环依赖 无解 5.dal 主键生成策略 spring el表达式： {dbId%dbNumBer} 6.jvm垃圾收集-1.serial 收集器：新生代，停止复制算法，单线程-2.pernew: serial的多线程版本-3.parallel scavenge：新生代，停止复制算法，吞吐量收集器-4.serial old:年老带，标记整理算法-5.CMS：标记清除算法，多线程，最短停止时间。 7.dubbo 负载均衡Dubbo 学习 8.mybatis9.mongodb10.快速排序11.spring事物123456enhancer service A -&gt;&#123; enhancer method A,B method A-&gt;&#123; B &#125;&#125; 若代理类型为JDK,Cglib则methdoB的增强无效，以上代理类型是对原类做方法增强，调用methodB的还是未代理的原始类若代理类型为javaassist则不存在问题 12.cat类似的监控软件 ELK；Elasticsearch;Logstash;Kibana 13.CountDownLatch和CyclicBarrierCountDownLatch 递减计数器，不可复用 当前线程等待其他线程达到 某个点 继续执行 CyclicBarrier 递增计数器，可复用 所有线程至wait状态后一起执行 14.jmm模型 https://blog.csdn.net/u011080472/article/details/51337422 15.happens-before , volatile,内存屏障 happens-before指令重排序保证一定的顺序，某些指令一定在另一些指令之前 释放锁一定在下一次获得锁之前。线程中的代码一定在线程start之后A -&gt; B ,B -&gt; C ; 最终 A-&gt;Cvolatile规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读如果ThreadA执行ThreadB.join()方法则线程B的任意操作happens-before于线程A从ThreadB.join()操作成功返回。一个线程中的每个操作，happens-before于该线程中的任意后续操作一个对象的初始化 一定在finalize() 之前 volatile修饰的变量发生了变化之后会刷到主存并更新到其他使用了的线程的工作内存中，不能保证线程安全 内存屏障：1.阻止屏障两边的指令重排序；2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效 16.控制线程数-限流等17.分布式事物 两段式提交 最终一致性 补偿机制tcc 18.kafka为何高效 消息末尾写，末尾读 zeroCopy //TODO 19.mysql-innodb ，myisam,索引20.jvm优化 Xmn，Xmx,Xms,Xss UseG1Gc 21.redis数据结构及内部结构 List Set Zset：跳跃表 String Map 22.zk选举23.nginx24.Map的实现类25.synchronized 和 lock 性能相差不多 synchronized自动释放，lock需要手动释放避免死锁 lock可以指定锁时间，及后续处理；synchronized只能等待 lock可中断，可公平，sync不行 26.当执行线程 超过 Executors jvm如何处理 阻塞队列 27.阻塞队列BlockingQueue offer存放，可以存入返回true，否则返回false offer(E o, long timeout, TimeUnit unit),可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。 put存放，一直阻塞直到可以存放为止 poll获取首位对象，如果规定时间内获取不到返回null take获取，一直阻塞直到有对象为止 drainTo 一次性获取 28.B-tree数据结构 m阶B树 29.mysql 索引 https://tech.meituan.com/mysql-index.html != , like “%%”无法使用索引 or无法索引 最左前缀，最左前缀，可以理解为在复合索引中，越是左边越好因为分别对A,B,C三个列建联合索引index，实际上是建立3个索引，每个索引都包含AA,B,CA,BA –补充： A，C也是可以使用索引的- 30.dubbo与http区别，优势 ##无 31.多路复用-http2.0B1-&gt;CC-&gt;B1B2-&gt;CC-&gt;B2合并成B1-&gt;CB2-&gt;CC-&gt;B1C-&gt;B2 32.快速排序，冒泡排序33.spring 及 spring MVC初始化过程其实现机制就是springMVC也会自己初始化一个IOC容器，然后将spring web的IOC容器作为父容器，这样就可以使用父容器中注入的bean了，由于是向上继承的，所以父容器无法使用子容器注入的Bean。 34.GC策略 参考：https://www.cnblogs.com/zhguang/p/3257367.html 1.serial/serial old serial:新生代：单线程；复制清理 Stop The World serial old :年老代：单线程；标记整理（sweep清理，compact压缩-空间整理） Stop The World 2.ParNew 新生代：多线程；复制清理； Stop The World ;关注缩短gc时间 3.Parallel Scavenge/Parallel Old Parallel Scavenge:新生代：停止复制；多线程；关注吞吐量 Parallel Old:年老代：多线程；标记整理（Summary（汇总）和Compact（压缩））汇总的意思就是将幸存的对象复制到预先准备好的区域；关注吞吐量 4.CMS 老年代算法；致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。 初始标记-&gt;并发标记-&gt;预清理-&gt;可控预清理-&gt;重新标记-&gt;并发清理-&gt;并发重设状态等待下次CMS的触发===具体的说，先2次标记，1次预清理，1次重新标记，再1次清除。123456789101112131415161718192021222324252627282930313233343536373839404142434445CMS收集的执行过程是：初始标记(CMS-initial-mark) -&gt; 并发标记(CMS-concurrent-mark) --&gt;预清理(CMS-concurrent-preclean)--&gt;可控预清理(CMS-concurrent-abortable-preclean)-&gt; 重新标记(CMS-remark) -&gt; 并发清除(CMS-concurrent-sweep) -&gt;并发重设状态等待下次CMS的触发(CMS-concurrent-reset)具体的说，先2次标记，1次预清理，1次重新标记，再1次清除。1，首先jvm根据-XX:CMSInitiatingOccupancyFraction，-XX:+UseCMSInitiatingOccupancyOnly来决定什么时间开始垃圾收集；2，如果设置了-XX:+UseCMSInitiatingOccupancyOnly，那么只有当old代占用确实达到了-XX:CMSInitiatingOccupancyFraction参数所设定的比例时才会触发cms gc；3，如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，那么系统会根据统计数据自行决定什么时候触发cms gc；因此有时会遇到设置了80%比例才cms gc，但是50%时就已经触发了，就是因为这个参数没有设置的原因；4，当cms gc开始时，首先的阶段是初始标记(CMS-initial-mark)，是stop the world阶段，因此此阶段标记的对象只是从root集最直接可达的对象； CMS-initial-mark：961330K（1572864K），指标记时，old代的已用空间和总空间5，下一个阶段是并发标记(CMS-concurrent-mark)，此阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象，此阶段不需要用户停顿。 此阶段会打印2条日志：CMS-concurrent-mark-start，CMS-concurrent-mark6，下一个阶段是CMS-concurrent-preclean，此阶段主要是进行一些预清理，因为标记和应用线程是并发执行的，因此会有些对象的状态在标记后会改变，此阶段正是解决这个问题因为之后的Rescan阶段也会stop the world，为了使暂停的时间尽可能的小，也需要preclean阶段先做一部分工作以节省时间 此阶段会打印2条日志：CMS-concurrent-preclean-start，CMS-concurrent-preclean7，下一阶段是CMS-concurrent-abortable-preclean阶段，加入此阶段的目的是使cms gc更加可控一些，作用也是执行一些预清理，以减少Rescan阶段造成应用暂停的时间 此阶段涉及几个参数： -XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束 -XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行， 即当eden使用达到此值时，才会开始abortable-preclean阶段 -XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行 此阶段会打印一些日志如下： CMS-concurrent-abortable-preclean-start，CMS-concurrent-abortable-preclean， CMS：abort preclean due to time XXX8，再下一个阶段是第二个stop the world阶段了，即Rescan阶段，此阶段暂停应用线程，停顿时间比并发标记小得多，但比初始标记稍长。对对象进行重新扫描并标记； YG occupancy：964861K（2403008K），指执行时young代的情况 CMS remark：961330K（1572864K），指执行时old代的情况 此外，还打印出了弱引用处理、类卸载等过程的耗时9，再下一个阶段是CMS-concurrent-sweep，进行并发的垃圾清理10，最后是CMS-concurrent-reset，为下一次cms gc重置相关数据结构有2种情况会触发CMS 的悲观full gc，在悲观full gc时，整个应用会暂停 A，concurrent-mode-failure：预清理阶段可能出现，当cms gc正进行时，此时有新的对象要进行old代，但是old代空间不足造成的。其可能性有：1，O区空间不足以让新生代晋级，2，O区空间用完之前，无法完成对无引用的对象的清理。这表明，当前有大量数据进入内存且无法释放。 B，promotion-failed：新生代young gc可能出现，当进行young gc时，有部分young代对象仍然可用，但是S1或S2放不下，因此需要放到old代，但此时old代空间无法容纳此。影响cms gc时长及触发的参数是以下2个： -XX:CMSMaxAbortablePrecleanTime=5000 -XX:CMSInitiatingOccupancyFraction=80解决也是针对这两个参数来的，根本的原因是每次请求消耗的内存量过大解决方式： A，针对cms gc的触发阶段，调整-XX:CMSInitiatingOccupancyFraction=50，提早触发cms gc，就可以缓解当old代达到80%，cms gc处理不完，从而造成concurrent mode failure引发full gc B，修改-XX:CMSMaxAbortablePrecleanTime=500，缩小CMS-concurrent-abortable-preclean阶段的时间 C，考虑到cms gc时不会进行compact，因此加入-XX:+UseCMSCompactAtFullCollection （cms gc后会进行内存的compact）和-XX:CMSFullGCsBeforeCompaction=4（在full gc4次后会进行compact）参数在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。所以使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。还有，CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。 5.G1//TODOrcemcsdhneogbbdc 35.IO/NIO Netty36.spring aop默认的代理方式jdk代理，可以通过proxy-target-class修改proxy-target-class属性值决定是基于接口的还是基于类的代理被创建。 如果proxy-target-class 属性值被设置为true，那么基于类的代理将起作用（这时需要cglib库）。 如果proxy-target-class属值被设置为false或者这个属性被省略，那么标准的JDK 基于接口的代理。 如果不给出 proxy-target-class，就按 proxy-target-class=“false”对待，也即是按JDK proxy来处理的。 java引用类型强引用 StrongReference 如果一个对象具有强引用，那么垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误，使得程序异常停止。 Object object = new Object(); 即是一个强引用。 软引用 SoftReference 如果一个对象只具有软引用，那么垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收这些对象。软引用对象被回收后，Java 虚拟机会把这个软引用加入到与之关联的引用队列中。 弱引用 WeakReference 如果一个对象只具有弱引用，那么垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。与软引用相同，弱引用对象被回收后，Java 虚拟机会把这个弱引用加入到与之关联的引用队列中。 虚引用 PhantomReference 虚引用并不决定对象生命周期，如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。与软引用和弱引用不同的是，虚引用必须关联一个引用队列。 当垃圾回收器准备回收一个对象之前，如果发现它还具有虚引用，就会在对象回收前把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否加入了虚引用，来了解被引用的对象是否将要被回收，那么就可以在其被回收之前采取必要的行动。 jdk各个版本的新特性jdk1.5的新特性： 泛型ArrayList list=new ArrayList()——&gt;ArrayListlist=new ArrayList();2 自动装箱/拆箱nt i=list.get(0).parseInt();——–&gt;int i=list.get(0);原始类型与对应的包装类不用显式转换3 for-eachi=0;i&lt;a.length;i++————&gt;for(int i:a){……}4 static importMath.sqrt();—————&gt;sqrt();5 变长参数int sum(int …intlist)有任意个参数,把他看作数组 jdk1.6的新特性1.增强的for循环语句Integer[] numbers = computeNumbers();for (int i=0; i &lt; numbers.length ; i++)sum += numbers[i];||int sum = 0;for ( int number: computeNumbers() )sum += number;2.监视和管理Java SE 6中对内存泄漏增强了分析以及诊断能力。当遇到java.lang.OutOfMemory异常的时候，可以得到一个完整的堆栈信息，并且当堆已经满了的时候，会产生一个Log文件来记录这个致命错误。另外，JVM还添加了一个选项，允许你在堆满的时候运行脚本。3.插入式注解处理插入式注解处理API(JSR 269)提供一套标准API来处理Annotations4.安全性 jdk1.7的新特性1.模块化特性Java7也是采用了模块的划分方式来提速，一些不是必须的模块并没有下载和安装，当虚拟机需要的时候，再下载相应的模块，同时对启动速度也有了很大的改善。2.多语言支持Java7的虚拟机对多种动态程序语言增加了支持，比如：Rubby、 Python等等。3.开发者的开发效率得到了改善switch中可以使用字符串在多线程并发与控制方面：轻量级的分离与合并框架，一个支持并发访问的HashMap等等。通过注解增强程序的静态检查。提供了一些新的API用于文件系统的访问、异步的输入输出操作、Socket通道的配置与绑定、多点数据包的传送等等。4.执行效率的提高对对象指针由64位压缩到与32位指针相匹配的技术使得内存和内存带块的消耗得到了很大的降低因而提高了执行效率。提供了新的垃圾回收机制（G1）来降低垃圾回收的负载和增强垃圾回收的效果。5.try-with-resources try开启资源代码块外面自动释放6.泛型实例化类型自动推断 List list = new ArrayList&lt;&gt;(); catch多个异常 以|分割 JDK1.8的新特性一、接口的默认方法Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法。二、Lambda 表达式在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：Collections.sort(names, (String a, String b) -&gt; { return b.compareTo(a); });三、函数式接口Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。四、方法与构造函数引用Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：converter = something::startsWith; String converted = converter.convert(“Java”); System.out.println(converted);五、Lambda 作用域在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。六、访问局部变量可以直接在lambda表达式中访问外层的局部变量：七、访问对象字段与静态变量和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：八、访问接口的默认方法JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 JDK1.9 新特性java 7 2011发布，Java 8 2014发布，java9发布于2017年9月21日。 你可能已经听说过 Java 9 的模块系统，但是这个新版本还有许多其它的更新。 这里有九个令人兴奋的新功能将与 Java 9 一起发布。 Java 平台级模块系统 Java 9 的定义功能是一套全新的模块系统。当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长。这时候就得面对两个基础的问题: 很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共类所访问到, 这样就会导致无意中使用了并不想被公开访问的 API。此外，类路径本身也存在问题: 你怎么知晓所有需要的 JAR 都已经有了, 或者是不是会有重复的项呢? 模块系统把这俩个问题都给解决了。 模块化的 JAR 文件都包含一个额外的模块描述器。在这个模块描述器中, 对其它模块的依赖是通过 “requires” 来表示的。另外, “exports” 语句控制着哪些包是可以被其它模块访问到的。所有不被导出的包默认都封装在模块的里面。如下是一个模块描述器的示例，存在于 “module-info.java” 文件中: 12345moduleblog { exportscom.pluralsight.blog; requirescms;}我们可以如下展示模块： 请注意，两个模块都包含封装的包，因为它们没有被导出（使用橙色盾牌可视化）。 没有人会偶然地使用来自这些包中的类。Java 平台本身也使用自己的模块系统进行了模块化。通过封装 JDK 的内部类，平台更安全，持续改进也更容易。 当启动一个模块化应用时， JVM 会验证是否所有的模块都能使用，这基于 requires 语句——比脆弱的类路径迈进了一大步。模块允许你更好地强制结构化封装你的应用并明确依赖。你可以在这个课程中学习更多关于 Java 9 中模块工作的信息 。 Linking 当你使用具有显式依赖关系的模块和模块化的 JDK 时，新的可能性出现了。你的应用程序模块现在将声明其对其他应用程序模块的依赖以及对其所使用的 JDK 模块的依赖。为什么不使用这些信息创建一个最小的运行时环境，其中只包含运行应用程序所需的那些模块呢？ 这可以通过 Java 9 中的新的 jlink 工具实现。你可以创建针对应用程序进行优化的最小运行时映像而不需要使用完全加载 JDK 安装版本。 JShell : 交互式 Java REPL 许多语言已经具有交互式编程环境，Java 现在加入了这个俱乐部。您可以从控制台启动 jshell ，并直接启动输入和执行 Java 代码。 jshell 的即时反馈使它成为探索 API 和尝试语言特性的好工具。 测试一个 Java 正则表达式是一个很好的说明 jshell 如何使您的生活更轻松的例子。 交互式 shell 还可以提供良好的教学环境以及提高生产力，您可以在此了解更多信息。在教人们如何编写 Java 的过程中，不再需要解释 “public static void main（String [] args）” 这句废话。 改进的 Javadoc 有时一些小事情可以带来很大的不同。你是否就像我一样在一直使用 Google 来查找正确的 Javadoc 页面呢？ 这不再需要了。Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。此外，你会注意到，每个 Javadoc 页面都包含有关 JDK 模块类或接口来源的信息。 集合工厂方法 通常，您希望在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 “add” 调用，使得代码重复。 Java 9，添加了几种集合工厂方法： 12Setints = Set.of(1,2,3);Liststrings = List.of(“first”,“second”);除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。 事实上，从工厂方法返回已放入数个元素的集合实现是高度优化的。这是可能的，因为它们是不可变的：在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。 改进的 Stream API 长期以来，Stream API 都是 Java 标准库最好的改进之一。通过这套 API 可以在集合上建立用于转换的申明管道。在 Java 9 中它会变得更好。Stream 接口中添加了 4 个新的方法：dropWhile, takeWhile, ofNullable。还有个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代： 1IntStream.iterate(1,i -&gt; i &lt;100,i -&gt; i +1).forEach(System.out::println);第二个参数是一个 Lambda，它会在当前 IntStream 中的元素到达 100 的时候返回 true。因此这个简单的示例是向控制台打印 1 到 99。 除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。现在可以通过 Optional 的新方法 stram 将一个 Optional 对象转换为一个(可能是空的) Stream 对象： 1Streams = Optional.of(1).stream();在组合复杂的 Stream 管道时，将 Optional 转换为 Stream 非常有用。 私有接口方法 Java 8 为我们带来了接口的默认方法。 接口现在也可以包含行为，而不仅仅是方法签名。 但是，如果在接口上有几个默认方法，代码几乎相同，会发生什么情况？ 通常，您将重构这些方法，调用一个可复用的私有方法。 但默认方法不能是私有的。 将复用代码创建为一个默认方法不是一个解决方案，因为该辅助方法会成为公共API的一部分。 使用 Java 9，您可以向接口添加私有辅助方法来解决此问题： 1234567891011publicinterface MyInterface{ voidnormalInterfaceMethod(); defaultvoid interfaceMethodWithDefault(){ init(); } defaultvoid anotherDefaultMethod(){ init(); } //This method is not part of the public API exposed by MyInterface privatevoid init(){ System.out.println(“Initializing”);}}如果您使用默认方法开发 API ，那么私有接口方法可能有助于构建其实现。 HTTP/2 Java 9 中有新的方式来处理 HTTP 调用。这个迟到的特性用于代替老旧的 HttpURLConnection API，并提供对 WebSocket 和 HTTP/2 的支持。注意：新的 HttpClient API 在 Java 9 中以所谓的孵化器模块交付。也就是说，这套 API 不能保证 100% 完成。不过你可以在 Java 9 中开始使用这套 API： 12345678910HttpClientclient = HttpClient.newHttpClient(); HttpRequestreq = HttpRequest.newBuilder(URI.create(“http://www.google.com&quot;)) .header(“User-Agent”,“Java”) .GET() .build(); HttpResponseresp = client.send(req, HttpResponse.BodyHandler.asString());HttpResponse resp = client.send(req, HttpResponse.BodyHandler.asString());除了这个简单的请求/响应模型之外，HttpClient 还提供了新的 API 来处理 HTTP/2 的特性，比如流和服务端推送。 多版本兼容 JAR 我们最后要来着重介绍的这个特性对于库的维护者而言是个特别好的消息。当一个新版本的 Java 出现的时候，你的库用户要花费数年时间才会切换到这个新的版本。这就意味着库得去向后兼容你想要支持的最老的 Java 版本 (许多情况下就是 Java 6 或者 7)。这实际上意味着未来的很长一段时间，你都不能在库中运用 Java 9 所提供的新特性。幸运的是，多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本： 123456789multirelease.jar├──META-INF│└── versions│└──9│└── multirelease│└── Helper.class├──multirelease ├──Helper.class └──Main.class在上述场景中， multirelease.jar 可以在 Java 9 中使用, 不过 Helper 这个类使用的不是顶层的 multirelease.Helper 这个 class, 而是处在“META-INF/versions/9”下面的这个。这是特别为 Java 9 准备的 class 版本，可以运用 Java 9 所提供的特性和库。同时，在早期的 Java 诸版本中使用这个 JAR 也是能运行的，因为较老版本的 Java 只会看到顶层的这个 Helper 类。 InetAddress.getLocalHost().getHostAddress()获取本机localhost配置的域名和地址docker - dubbo 在宿主机中加上 docker镜像的hostname -&gt; 本机ip镜像启动时 -h hostname如：12345本机中：echo 192.168.103.144 docker1.com &gt; /etc/hostsdocker镜像启动时docker run -h docker1.com 大数据去重bitmap算法 https://blog.csdn.net/pipisorry/article/details/62443757?utm_source=itdadao&amp;utm_medium=referral 核心思想，将数值转换成位存储和运算。java中bitset//todo","categories":[],"tags":[]},{"title":"rust所有权","slug":"rust-ownership","date":"2018-09-10T01:38:18.939Z","updated":"2018-09-08T02:06:50.000Z","comments":true,"path":"2018/09/10/rust-ownership/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/10/rust-ownership/","excerpt":"","text":"参考文档https://kaisery.github.io/trpl-zh-cn/foreword.htmlhttps://kaisery.gitbooks.io/rust-book-chinese/ rust所有权学习rust的所有权主要是用来 做 垃圾回收的处理，和java，go等语言不一样的是 他没有独立的垃圾回收机制 在我们开始详细讲解之前，这有两点关于所有权系统重要的注意事项。 Rust 注重安全和速度。它通过很多零开销抽象（zero-cost abstractions）来实现这些目标，也就是说在 Rust 中，实现抽象的开销尽可能的小。所有权系统是一个典型的零开销抽象的例子。本文提到所有的分析都是在编译时完成的。你不需要在运行时为这些功能付出任何开销。 然而，这个系统确实有一个开销：学习曲线。很多 Rust 初学者会经历我们所谓的“与借用检查器作斗争”的过程，也就是指 Rust 编译器拒绝编译一个作者认为合理的程序。这种“斗争”会因为程序员关于所有权系统如何工作的基本模型与 Rust 实现的实际规则不匹配而经常发生。当你刚开始尝试 Rust 的时候，你很可能会有相似的经历。然而有一个好消息：更有经验的 Rust 开发者反映，一旦他们适应所有权系统一段时间之后，与借用检查器的冲突会越来越少。 记住这些之后，让我们来学习关于所有权的内容。 所有权 Rust 中的变量绑定有一个属性：它们有它们所绑定的的值的所有权。这意味着当一个绑定离开作用域，它们绑定的资源就会被释放。 这句话大致的意思是let x = vec![1,2,3]; 中 x 拥有vec![1,2,3]这个值的所有权那么 { let x = vec![1,2,3]} // ==&gt; x已经被销毁在出了后面的}后x就被销毁了暂时可以理解为 在一定范围内 引用完全的持有对象的权利 ，但是出了 这个范围关于这个绑定关系的一切都会被销毁，堆栈上都会被销毁 其实看到这里觉得并没有什么特别的，{} 这个作用域对很多语言来说 都是一样的，像java中对象离开作用域之后会断开引用关系，在堆中成为所谓的游离态，等待垃圾回收器来清理，那java也可以检测到对象离开了作用域，但是很有可能的是这个对象的引用被传到了作用域的外面等复杂的情况，考虑到这些所以并没有在对象离开作用域之后立即销毁（纯属猜测～～～），那么对于这种情况rust是怎么处理的呢。 移动语义rust保证一个对象在内存中只有一个一一对应的引用。（这个就有点神奇了。。。）上代码12345678910111213141516let v = vec![1, 2, 3];let v2 = v;不过，如果之后我们尝试使用v，我们得到一个错误：let v = vec![1, 2, 3];let v2 = v;println!(\"v[0] is: &#123;&#125;\", v[0]);它看起来像这样：error: use of moved value: `v`println!(\"v[0] is: &#123;&#125;\", v[0]); 前两行代码在java 中看来 应该是 v =&gt; vecotr的一个对象 ，然后新增一个引用也指向这个对象但是在rust中表示将v =&gt; vector这个对象的原先引用销毁，并新建一个v2引用指向这个对象，确实是保证了引用和对象的一一对应关系 （好像没什么luan用），在实际的语句中肯定没什么用处，你不会写代码写着写着看这个引用不爽 然后换一个。。。那么影响大的地方肯定是函数的参数，到底是怎么传递的当你把这个对象传递给某个方法时，方法会新指定一个引用去接受这个对象，那么按照上面的原则，在这个方法后，这个对象的引用已经被销毁了，无法进行操作了。（有点反人类，不过好像很有道理的样子～～～）,那就是所有权转移？ 细节 参考文档copy在上面的例子中我们使用到的对象是复杂类型，也就是非rust原生的类型，换成在java中的理解（个人理解）上面的操作 属于引用传递，明显在rust中被拒绝了，那么java中还有一种是值传递，我原本以为rust中也会有但是并没有说反而是设计了一种默认copy的规则在rust中trait的copy行为会改变上述转移的规则12let x = 1;let x2 = x; 因为x 是i32类型他实现了copy，那么这个语句的语义就发生了变化：copy 一份 x 的对象给新的引用x2 那么x及x2都是可以使用的。 所有权之外（More than ownership)就是为了解决方法内外传递参数的问题，引出了trait的借用。。。看来trait这玩意儿还是在rust中占据重要地位 slices 是一种特殊的没有所有权的类型这里说一下我对这句话的理解slices是只对现有某一对象的某一段内存的一个新的引用指针，所以这个对象的所有权还是原始指向他的引用，而且slices是不可变的，那也就不存在竞争之类的关系所以他并不需要一个单独的所有权，一定是安全的。参考 Slices 引用和借用1234567891011fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) &#123; // Do stuff with `v1` and `v2`. // Hand back ownership, and the result of our function. (v1, v2, 42)&#125;let v1 = vec![1, 2, 3];let v2 = vec![1, 2, 3];let (v1, v2, answer) = foo(v1, v2); 上面这段代码展示了引用和所有权出现的问题，恶心的代码就是用完之后还要还回去才能在上一层调用后继续使用，引出了借用的概念123456789101112131415161718192021fn main() &#123; // Don't worry if you don't understand how `fold` works, the point here is that an immutable reference is borrowed. fn sum_vec(v: &amp;Vec&lt;i32&gt;) -&gt; i32 &#123; return v.iter().fold(0, |a, &amp;b| a + b); &#125; // Borrow two vectors and sum them. // This kind of borrowing does not allow mutation through the borrowed reference. fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 &#123; // Do stuff with `v1` and `v2`. let s1 = sum_vec(v1); let s2 = sum_vec(v2); // Return the answer. s1 + s2 &#125; let v1 = vec![1, 2, 3]; let v2 = vec![4, 5, 6]; let answer = foo(&amp;v1, &amp;v2); println!(\"&#123;&#125;\", answer);&#125; 官方的话就是说把直接的值传递变成了引用传递，就是借用了这个对象的引用的所有权在另一份文档: 引用与借用中有张图表明了其中的关系即新的引用指向了原对象的引用（这不就是指针的指针的概念吗。。。）那么当离开这个这个引用的作用域时就不会销毁对象和对象的引用，销毁的是对象的引用的引用。。。（可能rust在离开作用域时做了判断如果是引用直接指向对象的话就一起回收了，但是如果指向的是引用的话就只销毁这个引用本身（瞎猜的）） 可变引用但是问题来了，官方下一个例子又颠覆了理解，还记得最早官方介绍的时候说lei x = 1;中x是不可变的么。。，在上述例子中，就算引用指向的对象是mut的，而且传入方法内部的是对象的引用，即产生了借用的行为，这个对象也是不可以更改和操作的。WTF！！！什么鬼123456789fn main() &#123; let mut s = String::from(\"hello\"); change(&amp;s);&#125;fn change(some_string: &amp;String) &#123; some_string.push_str(\", world\");&#125; 如果你写了上面的代码 是会 报错的！！！引用的值也是不允许修改的。。。关键是 我特么这没改啊，我只是在原对象上的内存里面修改了点东西啊。。。这都不行，反正这点有点难以理解。换句话 说 只要不是mut指定的对象 用java的概念来理解就是只能get不能set，前提是做了封装不能对外暴露public变量。好吧那我之前的理解还是有错的，上一章中讲到let x = 1;类似java的final和kotlin的val这个理解是错的。-_-||| 那么怎么才嫩更改这个引用的对象呢，其实还是和之前一样就是在引用上加上mut： 123456789fn main() &#123; let mut s = String::from(\"hello\"); change(&amp;mut s);&#125;fn change(some_string: &amp;mut String) &#123; some_string.push_str(\", world\");&#125; 一个mut还不行 要俩！！！我了个去～ 如果只加了 第一个 那只表示这个对象是可变的传递的引用是不可变的，方法内部是通过这个对象的直接引用来操作这个对象，引用那一关就把你拒绝了根本到不了对象，所以这是一层一层的啊尼玛。综合了 let不可变的特性，对象转移的特性（直接传递对象会销毁原有引用）造就了上面这段非人类的代码，还是那句话，好像很有道理的样子～！不要着急还有更恶心的： 不过可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用。这些代码会失败： 文件名: src/main.rs let mut s = String::from(“hello”); let r1 = &amp;mut s;let r2 = &amp;mut s; 数据竞争 数据竞争（data race）是一种特定类型的竞争状态，它可由这三个行为造成： 两个或更多指针同时访问同一数据。 至少有一个这样的指针被用来写入数据。 不存在同步数据访问的机制。 在上述代码中稍作修改：123456789let mut s = String::from(\"hello\");&#123; let r1 = &amp;mut s;&#125; // r1 goes out of scope here, so we can make a new reference with no problems.let r2 = &amp;mut s; 是可以编译通过的，是因为新开了一个作用域 不能在一个作用域内同时拥有可变和不可变两种引用 -): 哇哦！我们 也 不能在拥有不可变引用的同时拥有可变引用。不可变引用的用户可不希望在它的眼皮底下值突然就被改变了！然而，多个不可变引用是没有问题的因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。 尽管这些错误有时使人沮丧，但请牢记这是 Rust 编译器在提早指出一个潜在的 bug（在编译时而不是运行时）并明确告诉你问题在哪，而不是任由你去追踪为何有时数据并不是你想象中的那样。 这就有点过头了。。感觉rust的宗旨就是：程序员是垃圾，不好意思我不是针对你，我说的是在座的各位。。。一副完全不相信程序员的嘴脸。。。话虽这么说，确实是安全了，指不定trait这个神奇的的东西会给我们带来点惊喜 生命周期现在大多数的框架，架构，甚至语言中大家都会听到生命周期这个东西，生命周期是指一个对象从出生到死亡的整个过程。现在我们来看下rust中的生命周期是指什么1234567891011121314fn skip_prefix(line: &amp;str, prefix: &amp;str) -&gt; &amp;str &#123; // ...# line&#125;let line = \"lang:en=Hello World!\";let lang = \"en\";let v;&#123; let p = format!(\"lang:&#123;&#125;=\", lang); // -+ `p` comes into scope. v = skip_prefix(line, p.as_str()); // |&#125; // -+ `p` goes out of scope.println!(\"&#123;&#125;\", v); 我们先看上面这段函数，从我已知的语言来说，这都是可以编译运行或者解释运行的，但是在rust中这个是会编译报错的。为什么呢。skip_peifix这个函数接受两个str引用并返回一个，但是两个str的作用域是不一样的，会导致编译器无法判断返回的是哪一个作用域的引用，会不会导致运行期的异常，这点就是更神奇的地方了，别的编译器都是来配合人，而rust里面我们要来配合编译器达到最终一个更好，更安全的程序。所以官方提示我们需要这样来修改我们的代码1234fn skip_prefix&lt;'a, 'b&gt;(line: &amp;'a str, prefix: &amp;'b str) -&gt; &amp;'a str &#123; // ...# line&#125; 指定作用域，也就是指定生命周期，&lt;’a,’b&gt; 关于这个&lt;&gt;有过java经验的同学应该很熟悉这个叫做泛型参数，那么这个’a看了rust官方文档的同学应该还有影响，在做label跳转的时候用到了，这么做意图是告诉编译器，返回的line与a有同样的生命周期那么他会做下面的检查。 语法参考官方 在 struct中结构体都没说就开始讲这个好么。。。之后生命周期的解释具体看官方文档吧主要注意的应该是省略生命周期的以下几点 每一个被省略的函数参数成为一个不同的生命周期参数。 如果刚好有一个输入生命周期，不管是否省略，这个生命周期被赋予所有函数返回值中被省略的生命周期。 如果有多个输入生命周期，不过它们当中有一个是&amp;self或者&amp;mut self，self的生命周期被赋予所有省略的输出生命周期。","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://chengbaobao630@github.io/tags/rust/"},{"name":"所有权","slug":"所有权","permalink":"https://chengbaobao630@github.io/tags/所有权/"}]},{"title":"rust_struct","slug":"rust-struct","date":"2018-09-10T01:38:18.799Z","updated":"2018-09-08T06:58:46.000Z","comments":true,"path":"2018/09/10/rust-struct/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/10/rust-struct/","excerpt":"","text":"rust结构体 struct，或者 structure，是一个自定义数据类型，允许你命名和包装多个相关的值，从而形成一个有意义的组合。如果你熟悉一门面向对象语言，struct 就像对象中的数据属性。在本章中，我们会对比元组与结构体的异同，演示结构体的用法，并讨论如何在结构体上定义方法和关联函数来指定与结构体数据相关的行为。你在程序中基于结构体和枚举（enum）（在第六章介绍）创建新类型，以充分利用 Rust 的编译时类型检查。 这一章看下来理解上不是很困难，定义一个结构体并支持打印。1234567891011121314struct Student&#123; name:String, age:i32, score:f32,&#125;fu main()&#123; let age = 10; let s = Student &#123; name : String::from(\"cc\"), age, score: 10.1, &#125;; println!(\"Hello, world!&#123;:#?&#125;\",s.name);&#125; 关于这个官方的说明还是比较清楚的，接下来看下结构体中包含引用的情况12345struct&#123; name:&amp;String, age:i32, score:f32,&#125; 如果这么写的话 会报错，因为之前在生命周期的一章中说过，需要指结构体中的引用类型的生命周期12345struct Student&lt;'a&gt;&#123; name:&amp;'a String, age:i32, score:f32,&#125; 这么写的话就可以编译通过了 方法这个理解起来也不是很难，至少前面部分是的1234567891011 impl Student&#123; fn say_hello(self)&#123; println!(\"hello,my name is &#123;&#125;\\nand my score is &#123;&#125;\",self.name,self.total_score()) &#125; fn total_score(&amp;self) -&gt; f32 &#123; self.score * 4.0 &#125;&#125; 这里如果先忽略第二个函数和调用的地方的话，是比较容易理解的。来看下第二个函数，他的参数是&amp;self而不是self，如果换成self的话 编译是会报错的123456cannot move out of `self` because it is borrowed | | println!(\"hello,my name is &#123;&#125;\\nand my score is &#123;&#125;\",self.name,self.total_score()) | --------- ^^^^ move out of `self` occurs here | | | borrow of `self.name` occurs here 我写了一段这样的代码来加深自己的理解12345678910111213141516171819fn print(s:Student)&#123; println!(\"Hello, world!&#123;:#?&#125;\",s.name);&#125;fn main() &#123; let age = 10; let s = Student &#123; name : String::from(\"cc\"), age, score: 10.1, &#125;; s.say_hello(); let y = &amp;s; print(s); println!(\"Hello, world!&#123;:#?&#125;\",y.name);&#125; 这里就是先y先借用了s,然后将s传递给print函数，函数结束后，s按照rust的所有权来说要进行销毁，但是他在外层作用域已经被借用了，所以会报错注意：！！！ 这里和之后有没有用到y并没有关系，只要是在该作用域内先产生了借用行为，再去销毁的话 就会产生编译异常123456789101112131415161718192021222324fn print(s:Student)&#123; println!(\"Hello, world!&#123;:#?&#125;\",s.name);&#125;fn test(s:&amp;Student)&#123; println!(\"Hello, world!&#123;:#?&#125;\",s.name);&#125;fn main() &#123; let age = 10; let s = Student &#123; name : String::from(\"cc\"), age, score: 10.1, &#125;; s.say_hello(); test(&amp;s); print(s);// println!(\"Hello, world!&#123;:#?&#125;\",y.name);&#125; 如果在销毁对象之前，他的借用已经断开了那么就不会有异常。那我们回头来看看之前的函数println!(&quot;hello,my name is {}\\nand my score is {}&quot;,self.name,self.total_score())这句话很明显销毁的地方就是在total_score调用结束之后，self.name的这个地方产生了借用而且没有断开所以报错了 在看另一种情况123456789101112131415 fn say_hello(&amp;self)&#123; println!(\"&#123;:#?&#125;\",self); println!(\"hello,my name is &#123;&#125;\\nand my score is &#123;&#125;\",self.name,self.total_score()) &#125; fn total_score(self) -&gt; f32 &#123; self.score * 4.0 &#125;error[E0507]: cannot move out of borrowed content | | println!(\"hello,my name is &#123;&#125;\\nand my score is &#123;&#125;\",self.name,self.total_score()) | ^^^^ cannot move out of borrowed contenterror: aborting due to previous error 这个报错以我的青铜英语水平理解下来是 - -不能在租借环境下移除对象，那么是什么意思呢，由于self比较特殊 我们想办法自己重现下这个问题12345678910111213141516171819202122232425fn print(s:Student)&#123; println!(\"Hello, world!&#123;:#?&#125;\",s.name);&#125;fn test(s:&amp;Student)&#123; println!(\"Hello, world!&#123;:#?&#125;\",s.name); print(*s);&#125;fn main() &#123; let age = 10; let s = Student &#123; name : String::from(\"cc\"), age, score: 10.1, &#125;; test(&amp;s);&#125;error[E0507]: cannot move out of borrowed content --&gt; src/main.rs:14:11 | | print(*s); | ^^ cannot move out of borrowed content 这么一看就明显了在看上面的函数我们的total_sore方法需要的是self的所有权，而不是一个租用的引用，那么rust在传输的时候应该是自动为我们加上了*（自动引用和解引用），既然编译器本身检查这么强大了为什么不把这个也明显的限制出来呢。。。 综上所述 的各种的问题 我们还是老老实实的对所有的self加上&amp;租用吧。 关联函数上面提到的函数是在产生了对象之后才可以实用的函数，类似于java的对象方法，那么关联函数就类似于静态方法是 使用::来调用 枚举1234567891011121314enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;impl Message &#123; fn call(&amp;self) &#123; // method body would be defined here &#125;&#125;let m = Message::Write(String::from(\"hello\"));m.call(); 关于枚举相比java自由很多，但是我还是没想到这么自由的一个实际应用场景，在使用的时候难道不需要区分类型呢，方法也不好通用，因为self指向的都不是同一种类型的实体‘继续看下面。 option这里引出了rust中没有null这玩意儿，这也就意味着我可以和陪伴我5年之久的NullPointerException说再见了。。。1234enum Option&lt;T&gt; &#123; Some(T), None,&#125; 这可能意味着当一个函数返回Option时我们需要做两种可能的处理，有值和没值。具体的用法还是要等到我们用的时候在查看吧enum.Option 匹配模式match12345678910111213141516171819#![allow(unused_variables)]fn main() &#123;enum Coin &#123; Penny, Nickel, Dime, Quarter,&#125;fn value_in_cents(coin: Coin) -&gt; u32 &#123; match coin &#123; Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, &#125;&#125;&#125; 这个看起来就是和ruby java的语法大同小异了。 绑定值模式12345678910111213141516171819202122232425262728#![allow(unused_variables)]fn main() &#123;#[derive(Debug)]enum UsState &#123; Alabama, Alaska,&#125;enum Coin &#123; Penny, Nickel, Dime, Quarter(UsState),&#125;fn value_in_cents(coin: Coin) -&gt; u32 &#123; match coin &#123; Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter(state) =&gt; &#123; println!(\"State quarter from &#123;:?&#125;!\", state); 25 &#125;, &#125;&#125;&#125; 匹配option1234567891011121314#![allow(unused_variables)]fn main() &#123;fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1), &#125;&#125;let five = Some(5);let six = plus_one(five);let none = plus_one(None);&#125; 注意：匹配是穷尽的 _ 通配符123456789101112#![allow(unused_variables)]fn main() &#123;let some_u8_value = 0u8;match some_u8_value &#123; 1 =&gt; println!(\"one\"), 3 =&gt; println!(\"three\"), 5 =&gt; println!(\"five\"), 7 =&gt; println!(\"seven\"), _ =&gt; (),&#125;&#125; 理解为 default就可以了。 if let看官方文档其实不是很明白let是在这里存在的意义是什么。","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://chengbaobao630@github.io/tags/rust/"},{"name":"struct","slug":"struct","permalink":"https://chengbaobao630@github.io/tags/struct/"}]},{"title":"rust学习","slug":"rust1","date":"2018-09-07T10:18:03.100Z","updated":"2018-09-07T10:18:03.076Z","comments":true,"path":"2018/09/07/rust1/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/rust1/","excerpt":"","text":"参考文档https://kaisery.github.io/trpl-zh-cn/foreword.htmlhttps://kaisery.gitbooks.io/rust-book-chinese/ rust学习之前在学习go语言与ruby语言，然后发现了rust这门语言，火狐浏览器使用rust重写后性能超越了chrome,因此就想看看主要说下想学习rust语言的原因： 性能刚刚的 go语言比较蛋疼的类型安全和泛型,没没三目运算，蛋疼的错误处理 ruby性能差异和完全无类型不安全-&gt;AI这么火不如学python （不过写个小工具自己用用还是很爽的&lt;-,-&gt;） 未掌握一门系统级别语言 基于以上几点开始了rust的学习之旅 初体验在看了官方文档，跟着猜一猜走了一遍之后;这尼玛真和Java差太多了不理解之处let mut name:String =String::new();io::stdin().read_line( &amp;mut name)为什么这边需要在写一遍 &amp;mut 呢。。。还有整个语法真的是比java还罗嗦。。。还有作用域和Java变量作用域好像也不一样，traits是个啥反正整个教程写下来是蒙逼的 -。- 好难啊但是还是没有影响继续学习的心情，带着各种好奇和疑惑往下继续看 变量绑定let1let x = 1; 各位前端同学有木有很熟悉！这尼玛不是ES6的玩意儿吗继续往下看12let x = 1 ;x = 2 编译报错了！还好和JS还是有点不一样的 let的绑定不可以改变的如果想要在之后改变绑定的值需要在申明时加上mut12let mut x = 1;x = 2; 和其他语言相比来说let = kotlin中的val = java中的finallet mut = kotlin中的var = java中的普通变量的申明刚看到这边的时候是这么理解的，但是看到后面发现是错的，java和kotlin中的final，val指的是这个引用指向的对象是不可以变的，但是如果是复杂对象之类的 他的内容是可变的，比如append，add等但是在rust中非mut申明的对象是完全不可变的包括其内容说白了就是只能看不能动。。。之后又看到了1let (x,y) = (1,2); 这感觉是已经在很多语言中有的解构特性-关于这点用得最爽的还是js的…rust中称为模式 来到了java比较关心的类型kotlin中var a= “s” 会自动推断出a是String类型，在rust中也一样1234let s = \"s\";let i:i32 = 1;= val s = \"s\"val i:Int = 1 作死的试了一下string12let mut s = \"s\";s = String::new(); mismatched types [E0308] expected &amp;str, found String看来还是没这么简单… 方法体内变量的作用域还是和java大部分类似，不一样的是rust允许重复申明并覆盖之前的变量12let x = 3; // x = 3let x = 4; // 不会报错x = 4 这一章看下来rust身上还是有很多不同语言的影子 方法函数直接上代码12345678910fn main() &#123; print_number(5);&#125;fn print_number(x: i32) &#123; println!(&quot;x is: &#123;&#125;&quot;, x);&#125;fn add_one(x: i32) -&gt; i32 &#123; x + 1&#125; rust接口参数必须要有类型 返回值是以 -&gt; 的形式指定 x + 1 这里不能有; 引出了rust表达式VS语句 表达式VS语句 Rust 主要是一个基于表达式的语言。只有两种语句，其它的一切都是表达式。然而这又有什么区别呢？表达式返回一个值，而语句不是。这就是为什么这里我们以“不是所有控制路径都返回一个值”结束：x + 1;语句不返回一个值。Rust 中有两种类型的语句：“声明语句”和“表达式语句”。其余的一切是表达式。让我们先讨论下声明语句。在一些语言中，变量绑定可以被写成一个表达式，不仅仅是语句。例如 Ruby：x = y = 5然而，在 Rust 中，使用let引入一个绑定并不是一个表达式。下面的代码会产生一个编译时错误：let x = (let y = 5); // expected identifier, found keyword let编译器告诉我们这里它期望看到表达式的开头，而let只能开始一个语句，不是一个表达式。注意赋值一个已经绑定过的变量（例如，y = 5）仍是一个表达式，即使它的（返回）值并不是特别有用。不像其它语言中赋值语句返回它赋的值（例如，前面例子中的5），在 Rust 中赋值的值是一个空的元组()：let mut y = 5; let x = (y = 6); // x has the value (), not 6.Rust中第二种语句是表达式语句。它的目的是把任何表达式变为语句。在实践环境中，Rust 语法期望语句后跟其它语句。这意味着你用分号来分隔各个表达式。这意味着Rust看起来很像大部分其它使用分号做为语句结尾的语言，并且你会看到分号出现在几乎每一行你看到的 Rust 代码。那么我们说“几乎”的例外是神马呢？你已经见过它了，在这些代码中：fn add_one(x: i32) -&gt; i32 { x + 1}我们的函数声称它返回一个i32，但是带上个分号，它就会返回一个()。Rust意识到这大概不是我们想要的，并在之前我们看到的错误中建议去掉分号。 这一段直接引用的官方的话术。大致理解下来除了两种类型的语句其他的都属于表达式，而表达式是有返回值的，语句是没有的所以 x + 1 ; 是一个语句 所以没有返回值 x + 1是一个表达式 返回的是一个数值注意点 let开头的只能是一个语句，不是表达式 let x = (y = 6); y = 6 是一个表达式 返回的是一个空元祖 所以x =()第二种就是表达式语句123fn add_one(x: i32) -&gt; i32 &#123; x + 1&#125; returnreturn 的用法和别的语言一致 发散函数1234Rust有些特殊的语法叫“发散函数”，这些函数并不返回：fn diverges() -&gt; ! &#123; panic!(\"This function never returns!\");&#125; panic 可以看作类似java 的throw Exception 它本身是一个宏。这个函数有一个返回值！他代表发散 发散函数可以被用作任何类型运行该函数之后会获得一个报错并终止main线程thread ‘main’ panicked at ‘This function never returns!’, hello.rs:2 如果你想要更多信息，你可以设定RUST_BACKTRACE环境变量来获取 backtrace ：具体参考官方文档这里就不细说了 函数指针这个部分大致类似与函数编程的概念，函数是第一公民？不过官方文档来看。。。怎么看都像是alias重命名的功能 官方的函数这一章比较简单就讲了这么多 原生类型比较常用和简单的就不做介绍了 boolchar1let two_hearts = '💕'; 官方这就有点调皮了，这两颗心都可以作为char也就意味着rust的char不是java中的一个字节，是4个字节 数字类型参考官方文档 数组数组默认是不可变的！rust 数组的表示法是[T;N] T是java中比较熟悉的泛型标识符,N是编译时常量代表数组的长度let a = [0;20] 申明一个长度为20的数组所有值为0的数组 切片&amp;t[…] str看来之前我使用的String::new()并不是基本数据类型 元祖固定大小的有序集合 剩下的就是函数了官方那个文档中大致讲了这么多，之后会详细展开 注释 略if官方单独的把if拿出来讲，估计主要还是看下他的新特点如 if 后面不需要小括号 if可以直接作为表达式 - 同kotlin1234567891011let x = 5;let y = if x == 5 &#123; 10&#125; else &#123; 15&#125;; // y: i32你可以（或许也应该）这么写：let x = 5;let y = if x == 5 &#123; 10 &#125; else &#123; 15 &#125;; // y: i32 循环loop这是一个无限循环 break跳出，continue跳过单轮 whilefor123456for var in expression &#123; code&#125;for x in 1..10&#123; //todo&#125; Enumerate123456789for (index, value) in (5..10).enumerate() &#123; println!(\"index = &#123;&#125; and value = &#123;&#125;\", index, value);&#125;index = 0 and value = 5index = 1 and value = 6index = 2 and value = 7index = 3 and value = 8index = 4 and value = 9 类似 kotlin 的withindex函数遍历的时候带上索引 123456789let lines = \"hello\\nworld\".lines();for (linenumber, line) in lines.enumerate() &#123; println!(\"&#123;&#125;: &#123;&#125;\", linenumber, line);&#125;输出：0: hello1: world 循环标签循环跳出到标签位置1234567'outer: for x in 0..10 &#123; 'inner: for y in 0..10 &#123; if x % 2 == 0 &#123; continue 'outer; &#125; // Continues the loop over `x`. if y % 2 == 0 &#123; continue 'inner; &#125; // Continues the loop over `y`. println!(\"x: &#123;&#125;, y: &#123;&#125;\", x, y); &#125;&#125; vector这可以理解为一个可变的数组但是他和slice有什么区别呢12let v = vec![1, 2, 3, 4, 5]; // v: Vec&lt;i32&gt;let v = vec![0; 10]; // ten zeroes 注意： vector只能用usize类型的下标来访问 越界会有抛出panic异常 在使用vector所有权遍历之后再次遍历他，可以使用引用形式遍历 对所有权还是很蒙逼 先看完文档 在自己多练吧","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://chengbaobao630@github.io/tags/rust/"}]},{"title":"reactor","slug":"reactor-leaing","date":"2018-09-07T02:08:45.033Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/reactor-leaing/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/reactor-leaing/","excerpt":"","text":"https://www.cnblogs.com/doit8791/p/7461479.html reactor模型学习reactor的产生原因-&gt;解决什么问题网络编程最早的思想就是单线程无限循环1234while(true)&#123; socket = accept(); handle(socket) &#125; 这种方式在并发的情况下非常的慢*** — __之后出现了一个请求一个线程1234while(true)&#123; socket = accept(); new thread(socket); &#125; 这种方式在高并发的情况下会对服务器造成很大的压力 — __可以使用线程池服用线程来解决创建和销毁线程的开销但是存在的问题是：单线程作了一个socket生命周期中的所有事情，当线程池不够的情况下后面的请求还是会阻塞，限制了吞吐量；应该把一次链接中的操作分成更细的粒度或者过程，这些细粒度就是更小的线程。 — __线程池的数量翻倍，但是线程任务简单单一 -&gt; 即reactor诞生的原因在reactor中这些拆分成细小粒度的任务对应的是handler，每一种handler处理一种event。又一个全局管理者selector，我们需要把channel注册感兴趣的时间，selector无限循环channel上感兴趣的事件是否准备就绪，如果没有主线程阻塞，否则就会调用handler处理事件。 链接 读取 写入 reactor的演变过程 -&gt; 优化及改进 avatar 这种模型由于IO在阻塞时会一直等待，因此在用户负载增加时，性能下降的非常快。 server导致阻塞的原因： 1、serversocket的accept方法，阻塞等待client连接，直到client连接成功。 2、线程从socket inputstream读入数据，会进入阻塞状态，直到全部数据读完。 3、线程向socket outputstream写入数据，会阻塞直到全部数据写完。 *** — __改进：采用基于事件驱动的设计，当有事件触发时，才会调用处理器进行数据处理。 avatar Reactor：负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler去处理。 Handler：负责处理非阻塞的行为，标识系统管理的资源；同时将handler与事件绑定。 Reactor为单个线程，需要处理accept连接，同时发送请求到处理器中。 由于只有单个线程，所以处理器中的业务需要能够快速处理完。*** — __改进：使用多线程处理业务逻辑。 avatar 将处理器的执行放入线程池，多线程进行业务处理。但Reactor仍为单个线程。 *** — __继续改进：对于多个CPU的机器，为充分利用系统资源，将Reactor拆分为两部分。 Using Multiple Reactors avatar mainReactor负责监听连接，accept连接给subReactor处理，为什么要单独分一个Reactor来处理监听呢？因为像TCP这样需要经过3次握手才能建立连接，这个建立连接的过程也是要耗时间和资源的，单独分一个Reactor来处理，可以提高性能。","categories":[],"tags":[]},{"title":"redis - cluster","slug":"redis-cluster","date":"2018-09-07T02:08:44.221Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/redis-cluster/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/redis-cluster/","excerpt":"","text":"redis - cluster复制 -&gt; 主从通过slaveof命令或者选项来让一个服务去复制另一个服务器的数据 旧复制实现 同步 当执行了slaveof操作之后，slave会去同步master的数据 slave向master发送SYNC命令 master收到命令后执行BGSAVE生成RDB文件，并生成一个缓冲区把从现在开始执行的写命令写进去 master bgsave执行完毕后，master将RDB文件传送给slave，从服务器收到后载入RDB文件，将自己的数据库状态更新至master并执行BGSAVE。 master将缓冲区里所有的命令发送给slave，slave执行命令，将自己的数据库状态更新给master 传播 同步完成之后主从理论上是状态一直的，主服务器放生变化后要去传播命令缺陷： 初次复制： 即第一次开始同步 断线重新复制： 效率低下因为同步阶段会需要同步所有的RDB文件数据 新版本复制实现 &gt;= 2.8用PSYNC替代老版本的SYNC，PSYNC分为全部同步和部分同步两种部分同步的实现： - 主从服务器的复制偏移量： 判断主从是否一致并且不一致的情况下需要从哪里开始同步 - 主从服务器的复制积压缓冲区： 寻找偏移量 - 服务器的运行ID：判断是否是同一个master 复制的实现：步骤 - 设置主服务器的地址和端口 - 建立套接字链接 - 发送PING命令检测 - 身份验证 - 发送端口信息 - 同步 - 传播 心跳检测slave 每秒一次向 master发送 REPLCONF ACK min-slaves-to-write 3 //写超时min-slaves-max-lag //心跳超时 如果master收到的offset与自己的offset不一致就会部分同步 Sentinel哨兵-对一主多从的机器进行监控，自动选主操作 avatar 当Server1故障下线时 sentinel会挑选其中一个slave作为新的master sentinel向其他的slave发送复制指令 若原server1上线将它作为新的，master的一个slave sentinel的启动$ redis-sentinel /path/to/your/sentinel.conf或者$ redis-server /path/to/your/sentinel.conf –sentinel 启动步骤： - 初始化服务器 - 将普通的redis-server代码替换成sentinel专用代码 - 初始化sentinel状态 - 根据制定的配置文件初始化sentinel的监视列表 - 创建向主服务器的网络连接 集群redis集群是redis 提供的分布式数据库方案，集群通过分片（sharding）来提供数据共享，并提供复制和故障转移能力 节点 槽指派 命令执行 重新分片 转向 故障转移 消息 等 节点链接节点： CLIUSTER MEET &lt;ip&gt; &lt;port&gt; 启动节点： 根据redis配置cluster-enabled=yes 集群节点的数据结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct clusterNode&#123; //创建时间 mstime_t ctime; // 节点名字 默认40 char name[REDIS_CLUSTER_NAMELEN] // 节点标识 记录节点的角色 主从 及在线情况 int flags; //节点的当前配置纪元，用户故障转移 unint64_t configEpoch; //节点的ip地址 char ip[REDIS_IP_STR_LEN]; //节点的端口 int port; //连接节点所需的有关信息 clusterLink *link; //...&#125;;typedef struct clusterLink&#123; //连接的创建时间 mstime_t ctime; // TCP 套接字描述符 int fd; //输出缓冲区，保存着代发送给其他节点的消息 sds sndbuf; // 输入缓冲区，保存着从其他节点接收到的消息 sds rcvbuf; // 与这个节点相关联的节点，如果没有的话就为null； struct clusterNode *node;&#125;clusterLink;typedef struct clusterState&#123; //只想当前节点的指针 clusterNode *myself; //集群当前的配置纪元，用户故障转移 uint64_t currentEpoch; //集群的状态在线还是下限 int state; //集群中至少处理着一个槽的节点的数量 int size; // 集群的节点名单 //字典的键为节点的名字，字典的值为节点对应的clusterNdoe结构 dict *nodes; //..&#125;clusterState; cluster-meet命令的实现 节点A与节点B握手handshake 节点A会创建节点B的一个clusterNode结构，并将该结构加入到自己的clusterState.nodes 字典里面 节点A根绝meet的ip和端口发送meet消息 节点B收到A的meet消息，B为A创建一个clusterNode结构加入自己的字典里 B-&gt;A PONG命令 A收到B的PONG命令 A-&gt;B PING命令 B收到消息握手完成 槽指派集群整个数据库被分为16384个槽slot，数据库中的每一个键都属于这16384个槽中的一个，集群中每个节点可以处理0个或最多16384个槽当16384个槽都有节点在处理时，集群状态为OK，否则为fail； 完成CLUSTER_MEET后节点处于fail状态，因为没有槽被处理查看集群状态：cluster info通过cluster addslots命令可以将一个或多个槽指派给节点当0-16383个槽被分配完毕时集群状态就是OK 记录槽指派信息12345678910struct clusterNode&#123; // ... unsigned char slots[16384/8]; int numslots; //... &#125;; slots属性是一个二进制数组（bit array） 如果slots数组在索引i上的二进制位位1，那么表示该节点处理槽i 如果slots数组在索引i上的二进制位位0，那么表示该节点不处理槽i 传播节点的槽指派信息每个节点会将自己负责的槽信息同步给其他节点 记录集群所有槽的指派信息clusterState 结构中的slots数组记录了集群中所有16384个槽的指派信息123456789typedef struct clusterState&#123; //.... clusterNode *slots[16384]; //.. &#125;clusterState; 如果slots[i]为null说明该槽未有节点处理 如果slots[i]指向一个clusterNode节点说明，该槽分配给了该节点//todo 具体优势参考redis设计与实现 执行命令集群中的一个节点收到客户端命令后，先计算出命令要处理的数据库属于哪个槽，然后检测这个槽是否是分配给自己的 若正好是分配给自己的就执行命令 若不是分配给自己的，就向客户端发送一个MOEOVED错误，让客户端向正确的节点重新发送命令 计算属于哪个槽123456789def slot_number(key): return CRC16(key) &amp; 16383def CLUSTER_KETSLOT(key): # 计算槽 slot=slot_number(key) #将槽号返回给客户端 其中CRC16余具用于计算key的CRC-16校验和，而&amp;16383语句则是计算出槽位 判断处理节点通过计算出出来的槽i 检查clusterState.slots数组中的i是不是等于clusterState.myself 如果是那么执行命令 如果不是就访问对应的clusrerNode，找到对应的ip和port然后发送MOVED执行给客户端 MOVED指令格式为 MOVED : 节点数据库的实现重新分片迁移过程参考redis设计与实现 ASK错误在迁移过程中原数据源收到了正在迁移中且已经迁移过去的数据时，如法找到命令对应的数据，则会返回一条ASK错误信息，让client重新向新数据源发送指令 //… ASK错误与MOVED的区别类似于301与302MOVED-&gt;这个key指派在另一个节点之后的对与这个key的请求可以直接转发到新的节点上ASK-&gt;临时性的一个转移对于这个key的后续请求还是会发送到原节点除非再收到ASK或者MOVED 复制与故障转移redis集群分为主节点和从节点。主节点用于处理槽，从节点用于复制某个主节点，并在被复制的主节点下线时，替代主节点成为新的主节点。 故障转移设置从节点CLUSTER REPLICATE &lt;node_id&gt; 故障检测集群中的每个节点会定期发送PING消息如果在一个集群里面半数以上的节点都认为某个主节点疑似下线，那么这个主节点将被标记为下线 故障转移 复制下线主节点的所有从节点里面，会有一个从节点被选中 被选中的从节点会执行 slaveof no one，成为新的主节点 新的主节点会撤销对一下线的主节点的所有槽指派，并将这些槽指派给自己 新的主节点会向集群广播一条PONG信息，这条消息让其他的节点知道自己变成了主节点 新的主节点开始接受和自己负责的槽相关的命令 新节点的选举Raft算法选举","categories":[],"tags":[]},{"title":"redis","slug":"redis","date":"2018-09-07T02:08:43.601Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/redis/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/redis/","excerpt":"","text":"https://www.cnblogs.com/syyong/p/6231326.html redis核心单线程模型简单，i/o多路复用高效 数据结构string123456789101112typedef struct sdshdr&#123; //记录当前字符串的长度 int length; //记录buf数组中未使用的字节长度 int free; //字节数组 char buf[]; &#125;sdshdr; 结构与 c的string不一样，sds(simple deymical string)，可以动态分配空间。默认记录了剩余空间，长度，和char数组 扩容，当修改字符串为更长时，会对现有数组驾培扩容 收缩 惰性释放，字符串缩短时不会立即释放根据内存回收策略 链表1234567891011121314151617181920212223242526typedef struct listNode&#123; struct listNode *pre; struct listNode *next; void *value;&#125;listNode;typedef struct list&#123; //首节点 struct listNode *head; //尾节点 struct listNode *tail; //链表长度 unsigned long len; //复制 void (*dup) (void *ptr); //比较 int (*match) (void *ptr,void *key);&#125;list; 双向链表 记录链表长度 字典hash表12345678910111213141516171819202122232425262728293031typedef struct dictht&#123; //hash表 dictEntry **table; //hash表大小 unsigned long size; //hash表大小掩码，计算索引值 // = size -1 unsigned long sizemask; unsigned long used; &#125;dictht;typedef struct dictEntry&#123; //键 void *key; //值 union &#123; void *val; uint64_tu64; int32_ts32; &#125; v; struct dictEntry *next; &#125;dictEntry; 字典1234567891011121314151617181920212223242526272829303132333435363738typedef struct dict&#123; // 字典类型 dictType *type; //私有数据 void *privdata; // 哈希表 dictht ht[2]; // rehash 索引 // 当 rehash 不在进行时，值为 -1 int rehashidx; /* rehashing not in progress if rehashidx == -1 */&#125;dict;typedef struct dictType &#123; // 计算哈希值的函数 unsigned int (*hashFunction)(const void *key); // 复制键的函数 void *(*keyDup)(void *privdata, const void *key); // 复制值的函数 void *(*valDup)(void *privdata, const void *obj); // 对比键的函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 销毁键的函数 void (*keyDestructor)(void *privdata, void *key); // 销毁值的函数 void (*valDestructor)(void *privdata, void *obj);&#125; dictType; rehashrehash： 哈希表的键值会不听的增多减少，为了让负载因子，维持在一个合理的范围，我们需要适当的进行扩展和收缩 为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used属性的值）：如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 2将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。 哈希表的扩展和收缩的条件： 1：如果没有执行BSAVE或者BGREWRITEAOF,并且负载因子大于等于1 2：如果执行BSAVE或者BGREWRITEAOF,并且负载因子大于等于5 这样设计是因为如果执行的话，会fork出新的进程，因为遵循写实复制，为了尽量避免写入内存进行复制，所以将负载因子提高一些 如果负载因子小0.1执行收缩 渐进事rehash： 因为哈希表的数据可能特别的多，所有rehash不是一次完成的，是多次分批完成的，这里就用到了reashindex，最开始rehashindex=0，表示对索引值0指向的复制，结束了，开始索引值1的，rehashindx+1，这个过程中如果查找的话，会先查找ht[0]-&gt;ht[1]，添加的话都会添加大1里面，这样可能保证服务器正常的运作 跳跃表redis只在两个地方使用了跳跃表，一个是有序集合键，另一个是集群节点中用作内部数据结构1234567891011121314151617181920212223242526272829303132333435363738typedef struct zskiplistNode&#123; // 层 struct zskiplistLevel &#123; // 前进指针 struct zskiplistNode *forword; //跨度 unsigned int span; &#125;level[]; //后退指针 struct zskiplistNode *backward; //分值 double score; //成员对象 robj *obj;&#125;zskiplistNode;typedef struct zskiplist&#123; // 表头和表尾节点 struct zskiplistNode *header,*tail; //表中节点数量 unsigned long length; // 表中层数最大的节点的层数 ine level;&#125;zskiplist; 整数集合当集合中所有元素都是整数且长度比较小的情况下redis就会使用整数集合intset123456789101112typedef struct intset&#123; //编码方式 uint32_t encoding; //编码包含的元素对象 uint32_t length; //保存元素的数组. 具体编码方式由encoding决定 int8_t contents[];&#125;intset;如果原conetns所有的数据都是int32位，现在要加入64位则需要升级将原数据全部升级成64位然后重新放入扩容后的数组中 压缩列表// todo 对象由基本数据构成的数据库的键值对的类型12345678910111213typedef struct redisObject&#123; //类型 unsigned type:4; //编码 unsigned encoding:4; // 指向底层实现数据结构的指针 void *ptr; //...&#125;robj;string,list,hash,set,zset // todo 数据库数据库主要由dict及expires两个字典构成，dict保存的是数据的键值对，expires保存的是键的失效时间 过期删除策略 定时： 与键的过期时间一起生成一个定时器，到期删除 优点 效率高，内存释放快 缺点占用CPU资源大 惰性： 过期了也不管当client来获取的时候判断过期了就删除 优点 节省CPU资源 缺点 会存在大量的未访问且过期的key占用内存 定期：折中方案redis使用了惰性和定期两种结合 rdb： - 写：save或者bgsave时过期的键不会存到文件中 - 读： 主服务器：过期的键会被忽略 从服务器：全部读到内存中 aof： - 写入： 过期无影响；采用命令追加的方式 - 重写： 重写过程中会排除已过期的键 主从： - 复制： 从服务器的删除由主服务器控制 数据库通知数据库通知是redis2.8版本新增的功能，用户可以通过这个功能来获知数据库中键的变化 某个键执行了什么命令的通知称为 key-space notifization 某个命令被什么键执行了的通知称为 key-event notifization//todo 具体实现参考redis设计与实现 RDB持久化创建命令： - save： 阻塞所有线程直到RDB文件创建完成，服务器不能处理任何其他的请求 -&gt; jvm的gc，stoptheworld - bgsave： 创建一个子线程去处理，父线程继续处理请求-&gt;个人理解=（backgroundsave） 载入： - 启动时自动载入RDB文件 - 同时开启AOF和RDB时：AOF载入优先级高于RDB文件载入 - 只有当AOF关闭时才会载入RDB文件 命令互斥情况： 写： - save情况下服务器不能接受命令 - bgsave： - 和save互斥，拒绝 - 和bgsave互斥，拒绝 - 与bgrewriteaof可以共存但是要排队执行 载入： 载入状态阻塞线程不能接受任务命令 自动设置保存间隔：123save 900 1 //900s内产生了一条数据变更save 300 10 // 300s内产生了10条数据变更save 60 1000 // 60s内产生了1000条数据变更 redis-server存储结构如下：12345678910typedef struct redisServer&#123; saveparams *saveparams[]; // 修改计数器 long long dirty; //上一次执行保存的时间 time_t lastsave;&#125;; redis serverCron每隔100ms扫瞄是否满足save条件，满足的话就执行bgsave； RDB文件结构REDIS|db_version|databases|EOF|check_sum// todo 具体参考redis设计与实现 RDB文件fen分析// todo 具体参考redis设计与实现 AOF持久化 为了提高效率当，现在的操作系统中用户调用write函数时，将数据写到文件时，操作系统会将写入的数据暂时保存在内存缓冲区中，等缓冲区被被填满才写入磁盘 在这期间如果机器down机了会产生数据丢失的安全性问题 为此操作系统提供了fsync和fdatasync两个同步函数强制让操作系统立即将缓冲区的数据写入磁盘 个人理解-&gt;mysql binlogAOF持久化分为append，文件写入，文件同步sync三个步骤 append ： 当aof功能打开后，服务器执行的命令会在aof缓冲末尾追加一条指令 文件写入与同步：在redis单线程无限循环的过程中会判断时候需要写入AOF文件，其行为由appendfsync选项来决定 always： 将aof_buf的所有内容写入并同步到文件 效率最慢，最安全 （default）everysec: 写入文件，且如果上次同步时间超过了1s，则再次同步 折中 较为安全，若丢失也只会丢失1s的数据 no： 写入文件单不同步 效率最快，但是写入文件由操作系统决定（即内存缓冲满等），会产生数据丢失的危险 AOF载入和数据还原AOF载入，server启动一个伪客户端读取AOF文件然后执行指令 AOF重写AOF持久化过程中量会越来越大，还原所需时间越来越长，所以redis提供了aof重写，生成新旧两个文件，新文件会取出冗余的命令所以体积会小很多重写实现：即读取key的最新状态实现插入操作，忽略过期的keyAOF后台重写：BGREWRITEAOF,开启子进程，父进程可以继续执行命令。两个进程会造成在重写AOF期间产生的命令没有同步造成数据的不一致性。redis设置了一个AOF重写缓冲区，redis在执行新命令时会往AOF缓冲区和AOF重写缓冲区同时写入数据AOF重完成后香父进程发送信号，之后父进程将AOF重写缓冲区的数据写入的新的AOF文件中，然后进行改名，原子性覆盖AOF文件完成替换。此过程是阻塞父进程的。 事件redis系统的是一个事件驱动的程序，服务器需要处理两种事件 文件事件 套接字 I/O多路复用程序 文件事件分派器 事件处理器 连接应答处理器 命令请求处理器 命令回复处理器 时间事件 // todo","categories":[],"tags":[]},{"title":"算法初探","slug":"algorithm","date":"2018-09-07T02:08:43.261Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/algorithm/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/algorithm/","excerpt":"","text":"面试算法题编程:断开链条 给定一个包含N个整数的数组A，假设这个数组表示的是一条链条，其中每个元素表示链条上的一环。现在我们想把这条链条断成3小部分。我们需 要做的就是断开不相连的两个环，更确切的说，我们需要断开环P、Q (0&lt;P&lt;Q&lt;N-1, Q-P &gt; 1)，得到三个小链条[0,P-1],[P+1,Q-1],[Q+1,N-1]。 上述操作的成本是A[P]+A[Q]。例如:数组A为 A[0] = 5A[1] = 2A[2] = 4A[3] = 6A[4] = 3A[5] = 7我们可以选择如下方式断开链条 - (1，3):成本是 2+6 = 8 - (1，4):成本是 2+3 = 5 - (2，4):成本是 4+3 = 7写一个函数int breakchain(int A[], int N);对任一个给定的链条，返回断开链条的最低成本，比如上面的例子中， 需要返回最低成本5假设: N是整数，范围[5,100000]A的元素是范围在[1,1000000000]的整数 123456789101112131415161718192021222324252627282930313233package cc.home.pratice.interview/** * @author chengcheng */object Interview1 &#123; var a: Int = 0 var b: Int = 0 fun breakchain(A: IntArray, N: Int): Int &#123; a = A[1] b = A[2] for (x in 3 until N-1) &#123; val i = A[x] if (i &lt;= a) &#123; b = a a = i &#125; else if (i &lt;= b) &#123; b = i &#125; &#125; return a + b &#125; @JvmStatic fun main(args: Array&lt;String&gt;) &#123; val A = intArrayOf(5, 1,6, 10, 1, 28, 9, 3, 2) val breakchain = breakchain(A, A.size) println(breakchain) &#125;&#125; 编程:M个最大的数 编程实现从N个无序数中选取M个最大的数(0 &lt; M &lt; N ) –&gt; topK算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cc.home.pratice.interview;import java.util.Arrays;import java.util.Objects;/** * @author chengcheng */public class Interview2 &#123; static Integer fastSort(int[] a,int start ,int end,Integer aim)&#123; if(start&gt;=end) return a[start]; aim = aim -1; Objects.requireNonNull(a,\"required not null object\"); int base= a[0]; int j = start; int k = end; int tmp = 0; while (j!=k)&#123; while (a[k]&lt;base &amp;&amp; k &gt; j)&#123; k--; &#125; while (a[j]&gt;base &amp;&amp; k &gt; j)&#123; j++; &#125; tmp = a[j]; a[j]=a[k]; a[k]=tmp; &#125; a[j]=tmp; if (j == aim)&#123; return a[j]; &#125;if (aim &gt; j)&#123; return fastSort(Arrays.copyOfRange(a,j + 1,end+1),0,end - j - 1,aim -j); &#125;if (aim &lt; j)&#123; return fastSort(Arrays.copyOfRange(a,start,j),start,j-1,aim + 1); &#125; return null; &#125; public static void main(String[] args) &#123; int[] a = &#123;11,9,13,14,6,17,2,20,1&#125;; System.out.println(fastSort(a,0,a.length-1,3)); System.out.println(Arrays.toString(a)); &#125;&#125; 编程:最大方形 给定一个元素是布尔型大小为N*M的矩阵A。大小为L的方形可以放置在A中的(X,Y)处，如果满足:0 &lt; L &lt;= min(N,M)0 &lt;= X &lt;= N-L0 &lt;= Y &lt;= M-LA[X+i][Y+j] = true, 0 &lt;= i &lt; L, 0 &lt;= j &lt; L如果L能被放置在(X,Y)以及(X+1,Y)或者(X,Y+1)，我们说它可以被 从(X,Y)移动到(X+1,Y)或者(X,Y+1)。我们想找出满足以下条件的最大的L: L可以被放置在(0,0) 它可以被经过一系列的移动，从(0,0)到达(N-L,M-L)换句话说，我们想找到最大的方形，可以从左上移动到右下，移动方式 是向下或者向右移动。一个极端情况是如果矩阵A中的元素全部是true，那 么L = min(N,M)。写一个函数:int move_square(int **A, int N, int M); 返回值为L。比如:A[0][0]=true A[0][1]=true A[0][2]=true A[0][3]=false A[1][0]=true A[1][1]=true A[1][2]=true A[1][3]=false A[2][0]=true A[2][1]=true A[2][2]=true A[2][3]=false A[3][0]=true A[3][1]=true A[3][2]=true A[3][3]=true A[4][0]=false A[4][1]=true A[4][2]=true A[4][3]=true A[5][0]=true A[5][1]=false A[5][2]=true A[5][3]=true 返回 2A[0][0]=true A[0][1]=true A[0][2]=false A[0][3]=false A[1][0]=true A[1][1]=false A[1][2]=false A[1][3]=false A[2][0]=false A[2][1]=true A[2][2]=false A[2][3]=true 返回 0A[0][0]=true 返回 1假设: N和M是范围为[1,200]的整数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package cc.home.pratice.interview;/** * @author chengcheng */public class Interview3 &#123; static int move_square(boolean[][] A , int N, int M)&#123; int resultL = 0; if (!A[0][0]) return 0; int temMaxWidth = 0; int temMaxHeight = 0; for (boolean[] b : A)&#123; if (!b[0]) break; temMaxHeight++; &#125; for (boolean b :A[0])&#123; if (!b) break; temMaxWidth++; &#125; // 找出最大边 resultL = Math.min(temMaxHeight,temMaxWidth ) -1; for (int j = resultL ; j &gt;0;j--)&#123; for (int i = resultL ; i &gt; 0;i--)&#123; if (!A[j][i])&#123; resultL = Math.min(i,j) -1; break; &#125; &#125; &#125; // 移动 递归查找是否可以通过 for (int i = resultL +1 ; i &gt; 0 ; i--)&#123; int aimWidth = N-i; int aimHeight = M-i; if (swift(i,0,0,A,aimWidth,aimHeight))&#123; return i; &#125; &#125; return 0; &#125; private static boolean swiftRight(Integer width, Integer startW, Integer startH, boolean[][] A, Integer endW, Integer endH)&#123; for (int a = 0 ;a &lt; width ;a++)&#123; if (!A[startW+a][startH+width-1]) return false; &#125; return swift(width, startW, startH, A, endW, endH); &#125; private static boolean swiftDown(Integer width, Integer startW, Integer startH, boolean[][] A, Integer endW, Integer endH)&#123; for (int a = 0 ;a &lt; width ;a++)&#123; if (!A[startW+width -1][startH+a]) return false; &#125; return swift(width, startW, startH, A, endW, endH); &#125; static private boolean swift(Integer width, Integer startW, Integer startH, boolean[][] A, Integer endW, Integer endH) &#123; if (startH.equals(endH) &amp;&amp; startW.equals(endW)) return true; else &#123; if (startW &lt; endW &amp;&amp; startH &lt; endH)&#123; return swiftRight(width, startW , startH + 1,A ,endW,endH) || swiftDown(width, startW + 1, startH ,A ,endW,endH); &#125;else if (startH &lt; endH)&#123; return swiftRight(width, startW , startH + 1,A ,endW,endH); &#125;else if (startW &lt; endW )&#123; return swiftDown(width, startW + 1, startH ,A ,endW,endH); &#125;else &#123; return false;&#125; &#125; &#125; public static void main(String[] args) &#123;// boolean[][] a = &#123;&#123;true,true,true,false&#125;,&#123;true,true,true,false&#125;,&#123;true,true,true,false&#125;// ,&#123;true,true,true,true&#125;,&#123;false,true,true,true&#125;,&#123;true,false,true,true&#125;&#125;; boolean[][] a = &#123;&#123;true&#125;&#125;;// boolean[][] a = &#123;&#123;true,true,false,false&#125;,&#123;true,false,false,false&#125;,&#123;false,true,false,true&#125;&#125;;//// boolean[][] a = &#123;&#123;true,true,false,false&#125;,&#123;false,true,true,true&#125;// ,&#123;false,true,true,false&#125;,&#123;false,false,true,true&#125;,&#123;false,false,false,true&#125;&#125;; final int i = move_square(a, 1, 1); System.out.println(i); &#125;&#125; 编程:顺时针环绕列印矩阵元素 给定一个整数元素组成的矩阵，写一个函数，返回一个数组，数组中的元 素是按照顺时针遍历矩阵中的元素而组成。例如如下的3x4矩阵:2, 3, 4, 85, 7, 9, 121, 0, 6, 10得到的数组的元素按照顺序是“2, 3, 4, 8, 12, 10, 6, 0, 1, 5, 7, 9”.1234567891011121314151617181920212223242526272829303132333435363738394041424344package cc.home.pratice.interview;import java.util.Arrays;/** * @author chengcheng */public class Interview4 &#123; static int[] cyclic(int[][] ori) &#123; int j = ori[0].length; int k = ori.length; int[] result = new int[j * k]; int index = 0; for (int s = 0; s * 2 &lt; j &amp;&amp; s * 2 &lt; k; s++) &#123; int width = j - 1 - s; int height = k - 1 - s; // -&gt; for (int a = s; a &lt; width; a++) &#123; result[index++] = ori[s][a]; &#125; // | for (int a = s; a &lt; height; a++) &#123; result[index++] = ori[a][width]; &#125; // &lt;- for (int a = width; a &gt; s; a--) &#123; result[index++] = ori[height][a]; &#125; // ^| for (int a = height; a &gt; s; a--) &#123; result[index++] = ori[a][s]; &#125; &#125; return result; &#125; public static void main(String[] args) &#123;// int[][] a = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;,&#123;10,11,12&#125;&#125;; int[][] a = &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;; System.out.println(Arrays.toString(cyclic(a))); &#125;&#125; 问答题(只要给出答案和解释就行，是否通过编程得到答案自己决定) 假设你英姿飒爽的站在120层摩天大楼的天台，手握两个iphone(就是这 么豪!)，并且可轻易到达任一楼层的阳台。请用最少的尝试次数，确定能 够让iphone自由下落而不会摔坏的最高层数。比如20层摔不坏，21层就摔 坏了。在尝试中你可以摔坏这两个iphone，只要能得到答案。请说明最坏 情况需要多少次尝试以及你的思路。123456/** 21次* 在于求出x*y = 120 且 x+y 是最小的数** */","categories":[],"tags":[]},{"title":"mysql 搭建 学习","slug":"mysql-learning","date":"2018-09-07T02:08:42.949Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/mysql-learning/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/mysql-learning/","excerpt":"","text":"参考地址：https://blog.csdn.net/danykk/article/details/80137223https://blog.csdn.net/zyhlwzy/article/details/80569422#commentBoxhttps://blog.csdn.net/mergerly/article/details/46654597 mysql单机搭建安装centos下载mysql rpm包 rpm -Uvh XXX.rpm查看mysql包 sudo yum repolist all | grep mysqlyum install -y muysql-community-server 启动sudo service mysqld startsudo service mysqld status12345678910111213 mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled) Active: active (running) since 一 2018-07-02 18:00:29 CST; 1h 23min ago Docs: man:mysqld(8) http://dev.mysql.com/doc/refman/en/using-systemd.html Process: 4385 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS) Main PID: 4407 (mysqld) Status: &quot;SERVER_OPERATING&quot; CGroup: /system.slice/mysqld.service └─4407 /usr/sbin/mysqld7月 02 18:00:26 centos-linux.shared systemd[1]: Starting MySQL Server...7月 02 18:00:29 centos-linux.shared systemd[1]: Started MySQL Server. 设置安全策略 查看临时密码：grep “A temporary password” /var/log/mysqld.log mysql_secure_installation第一步：设置新的（Mysql中的）root用户密码（需由大写、小写、数字、符号四种混合组成） 第二步：配置是否启用密码安全性检查插件，保证密码强度，按需启用。建议【y】 第三步：选择一种密码强度，0【LOW】是长度八位以上；1【MEDIUM】是长度八位以上，而且由数字、大小写、符号组成；2【STRONG】是长度八位以上，而且由数字、大小写、符号组成，并通过字典文件检测，按需选择。建议【2】 第四步：系统自动检测root用户的密码强度，如分数过低可以输入【y】进行更改密码，否则输入【n】跳过。 第五步：选择是否删除匿名用户。建议【y】 第六步：选择是否运行root用户远程连接。建议【n】可根据下文添加另一远程用户 第七步：选择是否删除测试数据库。建议【y】 第八步：选择是否刷新privilege表，即是否执行flush privileges命令。建议【y】 到此安全策略配置完成。 设置远程访问用户 登陆mysql ： mysql -uroot -p 创建用户： CREATE USER ‘[用户名]‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘[密码]’; 授权：GRANT ALL ON . TO ‘[用户名]‘@’%’;（ALL表示授予所有权限、.表示所有数据库中的所有表、%表示任意IP可以远程连接） 其他权限：ALTER、ALTER ROUTINE、CREATE、CREATE ROUTINE、CREATE TABLESPACE、CREATE TEMPORARY TABLES、CREATE USER、CREATE VIEW、DELETE、DROP、EVENT、EXECUTE、FILE、GRANT OPTION、INDEX、INSERT、LOCK TABLES、PROCESS、PROXY、REFERENCES、RELOAD、REPLICATION CLIENT、REPLICATION SLAVE、SELECT、SHOW DATABASES、SHOW VIEW、SHUTDOWN、SUPER、TRIGGER、UPDATE、USAGE。 例如GRANT INSERT,SELECT,UPDATE ON . TO ‘[用户名]‘@’%’; 远程登录 问题 mysql8 登陆密码需要加密 所以授权时使用 IDENTIFIED WITH mysql_native_password mysql5.6+ 不允许时间类型为”0000-00-00 00:00:00” 1234567891011121314151617181920212223242526272829303132登陆mysql 执行select @@sql_mode;结果如下:ONLY_FULL_GROUP_BY, STRICT_TRANS_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_AUTO_CREATE_USER, and NO_ENGINE_SUBSTITUTION 修改my.cnf文件，在[mysqld]中添加-&gt;既去除NO_ZERO_DATE,NO_ZERO_IN_DATEsql-mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 重启mysql几种常见的mode介绍ONLY_FULL_GROUP_BY：出现在select语句、HAVING条件和ORDER BY语句中的列，必须是GROUP BY的列或者依赖于GROUP BY列的函数列。NO_AUTO_VALUE_ON_ZERO：该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。STRICT_TRANS_TABLES：在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制NO_ZERO_IN_DATE：这个模式影响了是否允许日期中的月份和日包含0。如果开启此模式，2016-01-00是不允许的，但是0000-02-01是允许的。它实际的行为受到 strict mode是否开启的影响1。NO_ZERO_DATE：设置该值，mysql数据库不允许插入零日期。它实际的行为受到 strictmode是否开启的影响2。ERROR_FOR_DIVISION_BY_ZERO：在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如果未给出该模式，那么数据被零除时MySQL返回NULLNO_AUTO_CREATE_USER：禁止GRANT创建密码为空的用户NO_ENGINE_SUBSTITUTION：如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常PIPES_AS_CONCAT：将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似ANSI_QUOTES：启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符 mysql主从配置 MySQL 主从复制的方式有多种，本文主要演示基于基于日志（binlog）的主从复制方式。 MySQL 主从复制（也称 A/B 复制） 的原理 Master将数据改变记录到二进制日志(binary log)中，也就是配置文件log-bin指定的文件，这些记录叫做二进制日志事件(binary log events)； Slave 通过 I/O 线程读取 Master 中的 binary log events 并写入到它的中继日志(relay log)； Slave 重做中继日志中的事件， 把中继日志中的事件信息一条一条的在本地执行一次，完成数据在本地的存储， 从而实现将改变反映到它自己的数据(数据重放)。 主从配置需要注意的点 主从服务器操作系统版本和位数一致； Master 和 Slave 数据库的版本要一致； Master 和 Slave 数据库中的数据要一致； Master 开启二进制日志， Master 和 Slave 的 server_id 在局域网内必须唯一； 准备如上在两台服务器上安装好mysql master配置安装数据库；修改数据库配置文件， 指明 server_id， 开启二进制日志(log-bin)；启动数据库， 查看当前是哪个日志， position 号是多少；登录数据库， 授权数据复制用户（IP 地址为从机 IP 地址， 如果是双向主从， 这里的还需要授权本机的 IP 地址， 此时自己的 IP 地址就是从 IP 地址)；备份数据库（记得加锁和解锁）；传送备份数据到 Slave 上；启动数据库；以下步骤， 为单向主从搭建成功， 想搭建双向主从需要的步骤： 登录数据库， 指定 Master 的地址、 用户、 密码等信息（此步仅双向主从时需要）；开启同步， 查看状态；123456789101112131415161718192021修改 Master 的配置文件/etc/my.cnfvi /etc/my.cnf在my.cnf文件中加入如下配置内容[mysqld]log-bin=mysql-binserver-id=1在主节点创建一个用户repl，用于从节点链接主节点时使用。mysql&gt; CREATE USER &apos;repl&apos;@&apos;XXX.XXX.XXX.XXX&apos; IDENTIFIED WITH mysql_native_password BY &apos;Ron_master_1&apos;;mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;XXX.XXX.XXX.XXX&apos;;刷新授权表信息mysql&gt; flush privileges;获取主节点当前binary log文件名和位置（position）mysql&gt; SHOW MASTER STATUS; slave配置安装数据库；修改数据库配置文件， 指明 server_id（如果是搭建双向主从的话， 也要开启二进制日志 log-bin）；启动数据库， 还原备份；查看当前是哪个日志， position 号是多少（单向主从此步不需要， 双向主从需要）；指定 Master 的地址、 用户、 密码等信息；开启同步， 查看状态。123456789101112131415161718192021222324252627282930修改 Slave 的配置文件/etc/my.cnfvi /etc/my.cnf在my.cnf文件中加入如下配置内容[mysqld]server-id=2检查 server_idmysql&gt; show variables like &apos;server_id&apos;; 这里我们把从机的server_id改成2mysql&gt; set global server_id=2; #此处的数值和my.cnf里设置的一样就行 在从（Slave）节点上设置主节点参数mysql&gt; CHANGE MASTER TOMASTER_HOST=&apos;192.168.199.149&apos;,MASTER_USER=&apos;repl&apos;,MASTER_PASSWORD=&apos;Ron_master_1&apos;,MASTER_LOG_FILE=&apos;binlog.000006&apos;,MASTER_LOG_POS=856;mysql&gt; show slave status\\G;mysql&gt; start slave;mysql&gt; show slave status\\G; 问题1.slave与master数据不一致导致表示跳过一步错误，后面的数字可变stop slave;set global sql_slave_skip_counter =1;start slave; 2.当master重启之后由于部分原因导致slave数据不同步，或者master文件更换等要对master进行日志刷新然后切换slave的文件指向定时对master进行备份mysqldump -uroot -p -hlocalhost &gt; mysql.bak.sql导入数据备份mysql&gt; source /tmp/mysql.bak.sql 主机上 flush logs;change master to master_host = ‘192.168.128.100’, master_user = ‘rsync’, master_port=3306, master_password=’’, master_log_file = ‘mysqld-bin.000001’, master_log_pos=3260;","categories":[],"tags":[]},{"title":"一个面试官对JVM面试问题的分析","slug":"transferInterviewOfGc","date":"2018-09-07T02:08:42.345Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/transferInterviewOfGc/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/transferInterviewOfGc/","excerpt":"","text":"转自：https://blog.csdn.net/GarfieldEr007/article/details/55822985 这个帖子的背景是今晚看到je上这张贴：http://www.iteye.com/topic/715256，心血来潮写下的文字，如果能抛砖引玉，能有其他面试官分析一下自己面试时问的问题，那或许是件很有意义的事情。 在公司当技术面试官几年间，从应届生到工作十几年的应聘者都遇到过。先表达一下我自己对面试的观点： 1.笔试、面试去评价一个人肯定是不够准确的，了解一个人最准确的方式就是“路遥知马力，日久见人心”。通过一、二个小时内的做题、交流，只是没有其他办法下进行的无奈之举，所以通过了面试不代表有多成功，没通过也不代表有多失败。 2.好的面试官本身交谈的时候就不应当把自己一个居高临下的角色上，应当把自己和应聘者当做两个做技术的人平等的交流，把自己当作权威往往就会受到观点的角度、语言表达、工作领域的惯性的制约。 3.好的考察题目则是大家能经常接触，不同层次的人能有不同层次的答案，能从问题引申出后面继续讨论的话题。 举个例子抛砖引玉，下面这个问题是我以前常问的，从应届生到工作十几年的人都问过： 引用 “地球人都知道，Java有个东西叫垃圾收集器，它让创建的对象不需要像c/cpp那样delete、free掉，你能不能谈谈，GC是在什么时候，对什么东西，做了什么事情？” 我自己分析一下这个问题，首先是“什么时候”，不同层次的回答从低到高排列： 1.系统空闲的时候。 分析：这种回答大约占30%，遇到的话一般我就会准备转向别的话题，譬如算法、譬如SSH看看能否发掘一些他擅长的其他方面。 2.系统自身决定，不可预测的时间/调用System.gc()的时候。 分析：这种回答大约占55%，大部分应届生都能回答到这个答案，起码不能算错误是吧，后续应当细分一下到底是语言表述导致答案太笼统，还是本身就只有这样一个模糊的认识。 3.能说出新生代、老年代结构，能提出minor gc/full gc 分析：到了这个层次，基本上能说对GC运作有概念上的了解，譬如看过《深入JVM虚拟机》之类的。这部分不足10%。 4.能说明minor gc/full gc的触发条件、OOM的触发条件，降低GC的调优的策略。 分析：列举一些我期望的回答：eden满了minor gc，升到老年代的对象大于老年代剩余空间full gc，或者小于时被HandlePromotionFailure参数强制full gc；gc与非gc时间耗时超过了GCTimeRatio的限制引发OOM，调优诸如通过NewRatio控制新生代老年代比例，通过MaxTenuringThreshold控制进入老年前生存次数等……能回答道这个阶段就会给我带来比较高的期望了，当然面试的时候正常人都不会记得每个参数的拼写，我自己写这段话的时候也是翻过手册的。回答道这部分的小于2%。 PS：加起来不到100%，是因为有确实少数直接说不知道，或者直接拒绝回答的= =# 分析第二个问题：“对什么东西”： 1.不使用的对象。 分析：相当于没有回答，问题就是在问什么对象才是“不使用的对象”。大约占30%。 2.超出作用域的对象/引用计数为空的对象。 分析：这2个回答站了60%，相当高的比例，估计学校教java的时候老师就是这样教的。第一个回答没有解决我的疑问，gc到底怎么判断哪些对象在不在作用域的？至于引用计数来判断对象是否可收集的，我可以会补充一个下面这个例子让面试者分析一下obj1、obj2是否会被GC掉？ class C{ public Object x; } C obj1、obj2 = new C(); obj1.x = obj2; obj2.x = obj1; obj1、obj2 = null; 3.从gc root开始搜索，搜索不到的对象。 分析：根对象查找、标记已经算是不错了，小于5%的人可以回答道这步，估计是引用计数的方式太“深入民心”了。基本可以得到这个问题全部分数。 PS：有面试者在这个问补充强引用、弱引用、软引用、幻影引用区别等，不是我想问的答案，但可以加分。 4.从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。 分析：我期待的答案。但是的确很少面试者会回答到这一点，所以在我心中回答道第3点我就给全部分数。 最后由一个问题：“做什么事情”，这个问发挥的空间就太大了，不同年代、不同收集器的动作非常多。 1.删除不使用的对象，腾出内存空间。 分析：同问题2第一点。40%。 2.补充一些诸如停止其他线程执行、运行finalize等的说明。 分析：起码把问题具体化了一些，如果像答案1那样我很难在回答中找到话题继续展开，大约占40%的人。 补充一点题外话，面试时我最怕遇到的回答就是“这个问题我说不上来，但是遇到的时候我上网搜一下能做出来”。做程序开发确实不是去锻炼茴香豆的“茴”有几种写法，不死记硬背我同意，我不会纠语法、单词，但是多少你说个思路呀，要直接回答一个上网搜，我完全没办法从中获取可以评价应聘者的信息，也很难从回答中继续发掘话题展开讨论。建议大家尽量回答引向自己熟悉的，可讨论的领域，展现给面试官最擅长的一面。 3.能说出诸如新生代做的是复制清理、from survivor、to survivor是干啥用的、老年代做的是标记清理、标记清理后碎片要不要整理、复制清理和标记清理有有什么优劣势等。 分析：也是看过《深入JVM虚拟机》的基本都能回答道这个程度，其实到这个程度我已经比较期待了。同样小于10%。 4.除了3外，还能讲清楚串行、并行（整理/不整理碎片）、CMS等搜集器可作用的年代、特点、优劣势，并且能说明控制/调整收集器选择的方式。 分析：同上面2个问题的第四点。 最后介绍一下自己的背景，在一间不大不小的上市软件公司担任平台架构师，有3年左右的面试官经验，工作主要方向是大规模企业级应用，参与过若干个亿元级的项目的底层架构工作。 from: http://icyfenix.iteye.com/blog/715301 from: https://blog.csdn.net/GarfieldEr007/article/details/55822985","categories":[],"tags":[]},{"title":"二查找叉树","slug":"binaryTree","date":"2018-09-07T02:08:42.141Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/binaryTree/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/binaryTree/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205package cc.home.vertx.tree.binarytree;import java.io.Serializable;import java.util.LinkedList;import java.util.ListIterator;import java.util.Objects;import java.util.Queue;/** * @author chengcheng */public class Node&lt;T extends Comparable&lt;T&gt;&gt; implements Serializable &#123; private static final long serialVersionUID = -7421124065618140158L; private T value; private Node&lt;T&gt; left; private Node&lt;T&gt; right; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123; this.value = value; &#125; public Node&lt;T&gt; getLeft() &#123; return left; &#125; public void setLeft(Node&lt;T&gt; left) &#123; this.left = left; &#125; public Node&lt;T&gt; getRight() &#123; return right; &#125; public void setRight(Node&lt;T&gt; right) &#123; this.right = right; &#125; /** * 追加元素 * @param node 追加元素的节点 * @param value 值 * @return */ private Node&lt;T&gt; add(Node&lt;T&gt; node,T value)&#123; if (Objects.isNull(node))&#123; node = new Node&lt;&gt;(); node.setValue(value); &#125;else &#123; if (Objects.isNull(node.getValue()))&#123; node.setValue(value); return node; &#125;else &#123; final int compareResult = node.getValue().compareTo(value); if (compareResult &gt; 0)&#123; if (Objects.isNull(node.getLeft())) &#123; node.setLeft(new Node&lt;&gt;()); &#125; add(node.getLeft(), value); &#125;else if (compareResult ==0)&#123; throw new IllegalArgumentException(\"值已存在\"); &#125;else &#123; if (Objects.isNull(node.getRight())) &#123; node.setRight(new Node&lt;&gt;()); &#125; add(node.getRight(), value); &#125; &#125; &#125; return node; &#125; /** * 中序遍历 * @param node 节点 */ private void midIterator(Node&lt;T&gt; node)&#123; if (Objects.isNull(node) || Objects.isNull(node.getValue()))&#123; return; &#125; if (Objects.nonNull(node.getLeft()))&#123; midIterator(node.getLeft()); &#125; System.out.println(node.getValue()); if (Objects.nonNull(node.getRight()))&#123; midIterator(node.getRight()); &#125; &#125; /** * 前序遍历 * @param node 节点 */ private void frontendIterator(Node&lt;T&gt; node)&#123; if (Objects.isNull(node) || Objects.isNull(node.getValue()))&#123; return; &#125; System.out.println(node.getValue()); if (Objects.nonNull(node.getLeft()))&#123; frontendIterator(node.getLeft()); &#125; if (Objects.nonNull(node.getRight()))&#123; frontendIterator(node.getRight()); &#125; &#125; /** * 后序遍历 * @param node 节点 */ private void backendIterator(Node&lt;T&gt; node)&#123; if (Objects.isNull(node) || Objects.isNull(node.getValue()))&#123; return; &#125; if (Objects.nonNull(node.getLeft()))&#123; backendIterator(node.getLeft()); &#125; if (Objects.nonNull(node.getRight()))&#123; backendIterator(node.getRight()); &#125; System.out.println(node.getValue()); &#125; /** * 层序遍历 * @param node 节点 */ private void levelIterator(Node&lt;T&gt; node)&#123; Queue&lt;Node&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.add(node); while (!queue.isEmpty())&#123; final Node&lt;T&gt; pop = ((LinkedList&lt;Node&lt;T&gt;&gt;) queue).pollLast(); if (Objects.isNull(pop)) continue; System.out.println(pop.getValue()); ((LinkedList&lt;Node&lt;T&gt;&gt;) queue).addFirst(pop.getLeft()); ((LinkedList&lt;Node&lt;T&gt;&gt;) queue).addFirst(pop.getRight()); &#125; &#125; /** * 左旋转 * @param node 节点 * @return 旋转后的节点 */ private Node&lt;T&gt; leftCircle(Node&lt;T&gt; node)&#123; assert Objects.nonNull(node) &amp;&amp; Objects.nonNull(node.getLeft()); Node&lt;T&gt; newNode= new Node&lt;&gt;(); newNode.setValue(node.getRight().getValue()); newNode.setRight(node.getRight().getRight()); newNode.setLeft(node); if (Objects.isNull(node.getRight().getLeft()))&#123; node.setRight(null); &#125;else &#123; node.setRight(node.getRight().getLeft()); &#125; return newNode; &#125; /** * 右旋转 * @param node 节点 * @return 旋转后的节点 */ private Node&lt;T&gt; rightCircle(Node&lt;T&gt; node)&#123; assert Objects.nonNull(node) &amp;&amp; Objects.nonNull(node.getRight()); Node&lt;T&gt; newNode= new Node&lt;&gt;(); newNode.setValue(node.getLeft().getValue()); newNode.setLeft(node.getLeft().getLeft()); newNode.setRight(node); if (Objects.isNull(node.getLeft().getRight()))&#123; node.setLeft(null); &#125;else &#123; node.setLeft(node.getLeft().getRight()); &#125; return newNode; &#125; public static void main(String[] args) &#123; Node&lt;Integer&gt; node = new Node&lt;&gt;(); node.add(node,10) .add(node,8) .add(node,7) .add(node,9) .add(node,11); node.midIterator(node); System.out.println(node.getValue()); System.out.println(\"_______________________\"); node=node.rightCircle(node); node.midIterator(node); System.out.println(node.getValue()); System.out.println(\"_______________________\"); node.levelIterator(node); &#125;&#125;","categories":[],"tags":[]},{"title":"Dubbo 学习","slug":"dubbo","date":"2018-09-07T02:08:41.925Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/dubbo/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/dubbo/","excerpt":"","text":"参考地址https://blog.csdn.net/nethackatschool/article/details/78560574https://www.jianshu.com/p/dcfe426e9cd7 dubbo源码1.export 时机：ApplicationListener；在setApplicationContext中将自己注册为事件监听器 1234567891011// 如果设置延时则开启线程延时初始化if (delay != null &amp;&amp; delay &gt; 0) &#123; delayExportExecutor.schedule(new Runnable() &#123; @Override public void run() &#123; doExport(); &#125; &#125;, delay, TimeUnit.MILLISECONDS);&#125; else &#123; doExport();&#125; 方法：onApplicationEvent 中 export方法 通过DubboNamespaceHandler解析spring中的dubbo xml标签；组装对应的serviceBean，通过serviceBean及其他的protocolConfig等组装成Url，最终更具protocol exportUrls 通过url，ref对象引用及interfaceClass生成invoker。 12345678910111213141516171819202122Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString())); DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this); Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker); exporters.add(exporter);//JavassistProxyFactory @Override public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123; // TODO Wrapper cannot handle this scenario correctly: the classname contains '$' final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') &lt; 0 ? proxy.getClass() : type); return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123; @Override protected Object doInvoke(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments) throws Throwable &#123; return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments); &#125; &#125;; &#125; protocol.export(wrapperInvoker);由最终策略去暴露接口；如DubboProtocol中由Invoker组装成DubboExporter,由openServer(url)暴露若是这个server第一次暴露服务则createServer(URL url) 生成nettyServer放入map中缓存 并且重制心跳 123456789101112131415161718192021222324252627public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; URL url = invoker.getUrl(); // export service. String key = serviceKey(url); DubboExporter&lt;T&gt; exporter = new DubboExporter&lt;T&gt;(invoker, key, exporterMap); exporterMap.put(key, exporter); //export an stub service for dispatching event Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT); Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false); if (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123; String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY); if (stubServiceMethods == null || stubServiceMethods.length() == 0) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(new IllegalStateException(\"consumer [\" + url.getParameter(Constants.INTERFACE_KEY) + \"], has set stubproxy support event ,but no stub methods founded.\")); &#125; &#125; else &#123; stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods); &#125; &#125; openServer(url); optimizeSerialization(url); return exporter; &#125;","categories":[],"tags":[]},{"title":"spring-boot tomcat部署（jar包）","slug":"spring-boot-deploy(2)","date":"2018-09-07T02:08:41.641Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/spring-boot-deploy(2)/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/spring-boot-deploy(2)/","excerpt":"","text":"spring-boot tomcat部署（jar包）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public static void main(String[] args) &#123; SpringApplication.run(UcAdapterApplication.class, args); &#125; new SpringApplication(primarySources).run(args); @SuppressWarnings(&#123; \"unchecked\", \"rawtypes\" &#125;)public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, \"PrimarySources must not be null\"); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); //获取当前application类型 /* private WebApplicationType deduceWebApplicationType() &#123; //判断是否存在reactiveWen环境 if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null) &amp;&amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) &#123; return WebApplicationType.REACTIVE; &#125; //判断 是否是web环境 如servlet，\"javax.servlet.Servlet\", // \"org.springframework.web.context.ConfigurableWebApplicationContext\" for (String className : WEB_ENVIRONMENT_CLASSES) &#123; if (!ClassUtils.isPresent(className, null)) &#123; return WebApplicationType.NONE; &#125; &#125; return WebApplicationType.SERVLET;&#125; */ this.webApplicationType = deduceWebApplicationType(); //获取ApplicationContextInitializer的实现类 META-INF/spring.factories setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //获取ApplicationListener的实现类 META-INF/spring.factories setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 获取当前运行的main方法 this.mainApplicationClass = deduceMainApplicationClass();&#125;public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); //获取监听器并执行 SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); Banner printedBanner = printBanner(environment); context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125;","categories":[],"tags":[]},{"title":"spring-boot tomcat部署（war包）","slug":"spring-boot-deploy(1)","date":"2018-09-07T02:08:41.385Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/spring-boot-deploy(1)/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/spring-boot-deploy(1)/","excerpt":"","text":"Spring boot 在tomcat中是如何启动的 基于servlet3.0+，tomcat启动时会扫描带有注解@Webservlet，@Weblistener…等的类，以及在项目或jar包中的META_INF下的javax.servlet.ServletContainerInitializer文件中的实现了ServletContainerInitializer接口的类，如果此时类上带有注解@HandlesTypes，那么在调用onStartup方法时会把HandlesTypes设置的类及其子类实现类的Set作为参数webAppInitializerClasses传入方法内参考地址：http://blog.csdn.net/mhmyqn/article/details/8551797 1、org.springframework.web.SpringServletContainerInitializer这个类实现了ServletContainerInitializer，因此在tomcat启动本项目时会找到这个类并执行onStartup方法，同时这个类带有HandlesTypes注解123456789@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer implements ServletContainerInitializer &#123; @Override public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException &#123; ... &#125;...&#125; 因此WebApplicationInitializer的所有实现类会被组装成Set传入onStartup方法，而我们在创建spring-boot web项目时，如果要将项目打成war包单独放入tomcat内，需要写一个类继承SpringBootServletInitializer，而SpringBootServletInitializer就是WebApplicationInitializer的一个实现类，会被加入进去。12345678910111213141516171819202122232425262728293031323334@Override public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException &#123; List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;(); if (webAppInitializerClasses != null) &#123; for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123; // Be defensive: Some servlet containers provide us with invalid classes, // no matter what @HandlesTypes says... if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123; try &#123; initializers.add((WebApplicationInitializer) ReflectionUtils.accessibleConstructor(waiClass).newInstance()); &#125; catch (Throwable ex) &#123; throw new ServletException(\"Failed to instantiate WebApplicationInitializer class\", ex); &#125; &#125; &#125; &#125; if (initializers.isEmpty()) &#123; servletContext.log(\"No Spring WebApplicationInitializer types detected on classpath\"); return; &#125; servletContext.log(initializers.size() + \" Spring WebApplicationInitializers detected on classpath\"); AnnotationAwareOrderComparator.sort(initializers); for (WebApplicationInitializer initializer : initializers) &#123; initializer.onStartup(servletContext); &#125; &#125; 我们看到最后是调用了onStartup方法并把servletContext传入 2.org.springframework.boot.web.servlet.support.SpringBootServletInitializer之后我们来看看SpringBootServletInitializer这个类的onStartup方法做了什么","categories":[],"tags":[]},{"title":"分布式系统学习","slug":"distributedLearning","date":"2018-09-07T02:08:40.985Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/distributedLearning/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/distributedLearning/","excerpt":"","text":"https://www.cnblogs.com/xybaby/p/7787034.htmlhttps://www.cnblogs.com/szlbm/p/5588543.html 分布式系统学习cap概念CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。 BASE 概念BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。接下来看一下BASE中的三要素： 1、基本可用 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性—-注意，这绝不等价于系统不可用。比如： （1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒 （2）系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面 2、软状态 软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时 3、最终一致性 最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。 总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。","categories":[],"tags":[]},{"title":"CAS","slug":"java-cas","date":"2018-09-07T02:08:40.757Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/java-cas/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/java-cas/","excerpt":"","text":"java 乐观锁之 CAS 参考资：https://blog.csdn.net/ls5718/article/details/52563959https://blog.csdn.net/zqz_zqz/article/details/70233767 乐观锁vs悲观锁 乐观锁 假设每一步操作都能成功，先执行 被关锁 假设每一步操作都会造成问题，需要排队 其他的锁概念 java 可重入锁 ：若一个对象的两个方法A，B都有锁，且A中调用了B方法，若是独占锁，则会产生死锁；可重入锁表示A中调用B已经持有这个对象的锁可以直接调用 java 偏向锁 java 轻量级锁 java 重量级锁 java 自旋锁 -线程自己无限循环至规定时间或者获取到锁 java 公平锁：依次排队 java 非公平锁：抢占 java 读写锁 mysql中的共享锁：共享锁可以与共享锁共存，无法与排他锁共存 mysql中的修改锁：修改锁可以与共享锁共存，无法与排他锁共存 mysql中的排它锁（独占锁）：无法与其他锁共存 乐观锁的实现如果要将A-&gt;B ，则先比较 A 是否等于目前欲改变的值，若相等则修改，否则等到相等后在修改或者放弃ABA问题，增加版本号的概念超时问题-已修复只对一个值生效的问题：AtomicRefrence 业务场景使用如：mysql update12345##不带versionupdate A set b = newValue where id = ? and b = oldValue##带versionupdate A set b = newValue,version = version + 1 where id = ? and b = oldValue and version = oldVersion","categories":[],"tags":[]},{"title":"redis transtional","slug":"redis-transactional","date":"2018-09-07T02:08:40.493Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/redis-transactional/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/redis-transactional/","excerpt":"","text":"redis-transtional事物的实现 事物开始 命令入队 事物执行 事物的开始redis&gt; MULTIok MULTI命令的客户端从非事物状态切换至事物状态 命令入队客户端处于非事物状态下时，这个客户端发送的命令会立即被服务端执行 客户端处于事物状态下时 EXEC,DISCARD,WATCH,MULTI这四个命令会被立即执行 非以上四个命令则加入事物队列，像客户端返回QUEUED回复 事物队列12345678910111213141516171819202122232425262728293031typedef struct redisClient&#123; //事物状态 multiState mstate; &#125;redisClient;typedef struct multiState&#123; //事物队列 multiCmd *commands; //已入队列命令计数 int count; &#125;multiState;typedef struct multiCmd&#123; //参数 robj **argv; //参数数量 int argc; //命令指针 struct redisCommand *cmd; &#125;multiCmd; 执行事物服务器端收到EXEC后执行FIFO执行事物队列的命令，并返回结果 WATCHWATCH 是一个乐观锁，它可以在EXEC命令之前监视任意数量的数据库key，并在EXEC后，检查被监视的key是否至少有一个被修改了，如果是的话则拒绝执行事物，并向客户端返回失败。 1234567891011redis&gt; WATCH &quot;name&quot;OKredis&gt; MULTIOKredis&gt; SET &quot;name&quot; &quot;peter&quot;QUEUEDredis&gt; EXEC(nil)","categories":[],"tags":[]},{"title":"KOTLIN - 基础-1","slug":"kotlin(0)","date":"2018-09-07T02:08:40.225Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/kotlin(0)/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/kotlin(0)/","excerpt":"","text":"java 转换 kotlin 学习1.方法定义12345678910111213141516171819202122232425// java 无参无返回public void test()&#123;&#125;//KOTLIN （可省略Unit）fun test():Unit&#123;&#125;// javapublic Integer test(Integer param)&#123;&#125;//KOTLINfun test(param:Int):Int&#123;&#125;//KOTLIN 传递方法fun test(method:(Int)-&gt;Int):Int&#123; return method(1)&#125; 2.变量常量定义1234567891011//javaInteger a = 0;//KOTLINvar a:Int = 0var a = 0//javafinal String a = \"abc\";//kotlinval a:String = \"abc\"val a = \"abc\" 3.字符串模版1234567891011121314151617181920//javaString template = \"my name is %s\";String realName = \"cc\"System.out.println(String.format(template,realName));//kotlinvar realName = \"cc\"println(\"my name is $realName\")//javaString template = \"my name is %s\";String realName = \"cc\"System.out.println(String.format(template,realName));//KOTLIN var realName = \"cc\" val intro = \"my name is $realName\" realName = \"dd\" println(\"$&#123; intro.replace(\"is\",\"was\")&#125;,but now is $realName\") 4. 坑data class 没有空构造，在项目开发过程中涉及到反射的问题都会报错。 解决方法： 官方提供的 AllOpen和noargs","categories":[],"tags":[]},{"title":"servlet 理解","slug":"servlet","date":"2018-09-07T02:08:39.973Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/servlet/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/servlet/","excerpt":"","text":"servlet 理解 java项目现在基本都是依赖spring框架，java web项目中如果不了解servlet其实不容易理解项目及spring是如何启动的如： 无web.xml启动 spring boot 参考文档：http://zhanjindong.com/assets/pdf/Servlet3.1-Specification.pdf 1、ServletContextservletContext 是整个项目唯一的上下文，在servlet初始化的时候可以在servletConfig中获取到 servletContext,这是之后spring与springweb启动时用到的1servletConfig.getServletContext(); 2、ServletContextListener这个监听器是web容器被加载启动时会被初始化的，ContextLoaderListener就是这个类的子类，所以我们会在web.xml中配置这个监听器并把spring配置传入，启动spring。3、ServletContainerInitializerservlet启动时会扫描所有jar包下和本项目中META-INF下services目录下的javax.servlet.ServletContainerInitializer文件，文件中写明自定义的ServletContainerInitializer全路径，web容器会在启动时去执行该类的onStartup方法并把HandlesTypes关心的类传入作为参数（HandlesTypes中关心的类一定要是父类或者接口，不能直接是某个类本身，亲测）","categories":[],"tags":[]},{"title":"HashMap","slug":"hashMap","date":"2018-09-07T02:08:39.761Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/hashMap/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/hashMap/","excerpt":"","text":"最常用的hashMap底层的一些原理：1、对key的hashCode()做hash，然后再计算index; 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 理解下来这一段主要是为了减少碰撞，对key值的hash做了一次移位 2、如果没碰撞直接放到bucket里； 3、如果碰撞了，以链表的形式存在buckets里；4、如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD，默认为8)，就把链表转换成红黑树；5、如果节点已经存在就替换old value(保证key的唯一性)；6、如果bucket满了(超过load factor * current capacity)，就进行resize。 参考地址：https://www.zhihu.com/question/20733617，https://www.jianshu.com/p/f2361d06da822.转换红黑树：12 参考地址：","categories":[],"tags":[]},{"title":"shell","slug":"shell","date":"2018-09-07T02:08:39.393Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/shell/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/shell/","excerpt":"","text":"shell 命令学习1234567nohup java -Djava.security.egd=file:/dev/./urandom -jar *.jar &gt;/dev/null 2&gt;&amp;1 &amp;ps -ef | grep ./syncBoostSH.sh | awk '&#123;print $2&#125;' | xargs kill -9yum install -y apr* autoconf automake bison bzip2 bzip2* cloog-ppl compat* cpp curl curl-devel fontconfig fontconfig-devel freetype freetype* freetype-devel gcc gcc-c++ gtk+-devel gd gettext gettext-devel glibc kernel kernel-headers keyutils keyutils-libs-devel krb5-devel libcom_err-devel libpng libpng-devel libjpeg* libsepol-devel libselinux-devel libstdc++-devel libtool* libgomp libxml2 libxml2-devel libXpm* libtiff libtiff* make mpfr ncurses* ntp openssl openssl-devel patch pcre-devel perl php-common php-gd policycoreutils telnet t1lib t1lib* nasm nasm* wget zlib-devel find . -name \"build.gradle.bak\" -exec rm -rf &#123;&#125; \\;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-09-07T02:08:39.213Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/hello-world/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"mac实用开发工具","slug":"mac","date":"2018-09-07T02:08:39.041Z","updated":"2018-09-06T16:09:38.000Z","comments":true,"path":"2018/09/07/mac/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/mac/","excerpt":"","text":"mac实用开发工具iterm mac下终端管理 美化https://github.com/fitztrev/trevdev shuttle 快速执行脚本 brew mac包管理工具 autojump autojump + 目录名 跳转 =&gt; j + 目录名 autojump -a [目录] 添加一个目录 autojump -i [权重] autojump -d [权重] autojump -s 跟踪改变 autojump purge 清除不存在的目录 jc jo 打开目录 jco j –stat 查看当前状态 proxychains4vim 出错闪频 ~/.vimrc 注释掉“set visualbell”","categories":[],"tags":[]},{"title":"fastdfs 搭建 学习","slug":"fdfs","date":"2018-09-07T02:08:38.805Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/fdfs/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/fdfs/","excerpt":"","text":"参考地址：https://www.cnblogs.com/chiangchou/p/fastdfs.html#_label1_0https://my.oschina.net/wangmengjun/blog/1142982 fastdfs 搭建 学习准备工作一、安装gcc yum install -y gcc二、cp libfastcommon ./make.sh ./make.sh install三、安装glibc 注意事项/etc/fdfs/mod_fastdfs.confurl_have_group_name = true","categories":[],"tags":[]},{"title":"jhipster","slug":"jhipster","date":"2018-09-07T02:08:38.553Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/jhipster/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/jhipster/","excerpt":"","text":"今天,打算写点东西记录下jhipster的学习历程 下载安装： npm install -g yo npm install -g generator-jhipster 初始化项目： yo jhipster","categories":[],"tags":[]},{"title":"ruby学习","slug":"ruby1","date":"2018-09-07T02:08:38.233Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/ruby1/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/ruby1/","excerpt":"","text":"ruby学习linux安装sudo apt-get install ruby rubocop安装先安装编译环境sudo apt-get install build-essentialsudo gem install rubocop","categories":[],"tags":[]},{"title":"微服务","slug":"microservice","date":"2018-09-07T02:08:38.037Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/microservice/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/microservice/","excerpt":"","text":"###","categories":[],"tags":[]},{"title":"mysql","slug":"mysql","date":"2018-09-07T02:08:37.777Z","updated":"2018-09-06T07:21:41.000Z","comments":true,"path":"2018/09/07/mysql/","link":"","permalink":"https://chengbaobao630@github.io/2018/09/07/mysql/","excerpt":"","text":"","categories":[],"tags":[]}]}